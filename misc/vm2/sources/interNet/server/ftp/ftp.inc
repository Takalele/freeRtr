Function doConn(var con:OneConnectionRecord;conN:LongInt):Boolean;
Var
  ntry:xDirEntryRec;
  buf:array[1..16*1024] of byte;

Procedure sendResp(a:String);
Begin;
a:=a+#13#10;
pipeLineSend(con.pipe,a[1],length(a));
con.time:=CurrentTime;
End;

Procedure sendDataStr(a:String);
Begin;
pipeLineSend(con.data,a[1],length(a));
con.time:=CurrentTime;
End;

Function getUnixRights(i:LongInt):String;
Var a:String;
Begin;
a:='';
if (i and xRights_Directory<>0) then a:='d' else a:='-';
if (i and xRights_OwnRead<>0) then a:=a+'r' else a:=a+'-';
if (i and xRights_OwnWrite<>0) then a:=a+'w' else a:=a+'-';
if (i and xRights_OwnExec<>0) then a:=a+'x' else a:=a+'-';
if (i and xRights_AnyRead<>0) then a:=a+'r' else a:=a+'-';
if (i and xRights_AnyWrite<>0) then a:=a+'w' else a:=a+'-';
if (i and xRights_AnyExec<>0) then a:=a+'x' else a:=a+'-';
if (i and xRights_AnyRead<>0) then a:=a+'r' else a:=a+'-';
if (i and xRights_AnyWrite<>0) then a:=a+'w' else a:=a+'-';
if (i and xRights_AnyExec<>0) then a:=a+'x' else a:=a+'-';
getUnixRights:=a;
End;

Function setUnixRights(a:string):LongInt;
Var i,o:LongInt;
Begin;
o:=0;
i:=BVal(a) and 7;
if (i and 1<>0) then o:=o or xRights_OwnExec;
if (i and 2<>0) then o:=o or xRights_OwnWrite;
if (i and 4<>0) then o:=o or xRights_OwnRead;
setUnixRights:=o;
End;

Function leadZero(i:longint):string;
Var a:String;
Begin;
a:=BStr(i);
while (length(a)<2) do a:='0'+a;
leadZero:=a;
End;

Function getDateForMDTM(d:xDirEntryDateTimeRec):String;
Begin;
getDateForMDTM:=leadZero(d.year)+leadZero(d.month)+leadZero(d.day)
   +leadZero(d.hour)+leadZero(d.minute)+leadZero(d.second);
End;

Function getDirListingNorm:String;
Var a,b:String;
Begin;
b:=getUnixRights(ntry.rights)+'   1 ';
b:=b+conv2hex(ntry.owner)+' grp ';
a:=BStr(ntry.size);
while (length(a)<13) do a:=' '+a;
b:=b+a;
a:=BStr(ntry.modified.Day);
while (length(a)<2) do a:=' '+a;
a:=MonthNames[ntry.modified.month]+' '+a;
b:=b+' '+a;
if (ntry.modified.year=CurrentYear) then begin;
  a:=leadZero(ntry.modified.hour)+':'+leadZero(ntry.modified.minute);
  end else begin;
  a:=BStr(ntry.modified.year);
  end;
while (length(a)<5) do a:=' '+a;
getDirListingNorm:=b+' '+a;
End;

Function getDirListingExt:String;
Var
  a:String;
  i:LongInt;
Begin;
a:='';
if (con.mlst and factNames_Type<>0) then begin;
  a:=a+'type=';
  if (ntry.rights and xRights_Directory=0) then a:=a+'file;' else a:=a+'dir;';
  end;
if (con.mlst and factNames_Size<>0) then begin;
  a:=a+'size='+BStr(ntry.size)+';';
  end;
if (con.mlst and factNames_Perm<>0) then begin;
  a:=a+'perm=';
  if (ntry.owner=con.uid) then begin;
    if (ntry.rights and xRights_Directory=0) then a:=a+'a' else a:=a+'c';
    a:=a+'d';
    end;
  if (ntry.rights and xRights_Directory=0) then begin;
    i:=0;
    if (ntry.owner=con.uid) then if (ntry.rights and xRights_OwnRead<>0) then i:=1;
    if (ntry.rights and xRights_AnyRead<>0) then i:=1;
    if (i<>0) then a:=a+'r';
    i:=0;
    if (ntry.owner=con.uid) then if (ntry.rights and xRights_OwnWrite<>0) then i:=1;
    if (ntry.rights and xRights_AnyWrite<>0) then i:=1;
    if (i<>0) then a:=a+'w';
    end else begin;
    i:=0;
    if (ntry.owner=con.uid) then if (ntry.rights and xRights_OwnRead<>0) then i:=1;
    if (ntry.rights and xRights_AnyRead<>0) then i:=1;
    if (i<>0) then a:=a+'le';
    i:=0;
    if (ntry.owner=con.uid) then if (ntry.rights and xRights_OwnWrite<>0) then i:=1;
    if (ntry.rights and xRights_AnyWrite<>0) then i:=1;
    if (i<>0) then a:=a+'mp';
    end;
  a:=a+'f;';
  end;
if (con.mlst and factNames_Create<>0) then begin;
  a:=a+'create='+getDateForMDTM(ntry.created)+';';
  end;
if (con.mlst and factNames_Modify<>0) then begin;
  a:=a+'modify='+getDateForMDTM(ntry.modified)+';';
  end;
getDirListingExt:=a;
End;

Function getSupportedFacts:String;
function x(a:string;i:byte):string;begin; if (con.mlst and i<>0) then a:=a+'*'; x:=a+';'; end;
Begin;
getSupportedFacts:=x('type',factNames_Type)+x('size',factNames_Size)+x('perm',factNames_Perm)
 +x('create',factNames_Create)+x('modify',factNames_Modify);
End;

Function changeMlstFacts(c:String):String;
Label f1,f2;
Var
  a,b:String;
  i,o:LongInt;
Begin;
o:=0;
b:='';
f1:
if (c='') then goto f2;
i:=pos(';',c);
if (i<1) then i:=666;
a:=kicsi(copy(c,1,i-1))+';';
c:=copy(c,i+1,255);
if (a='type;') then begin; o:=o or factNames_Type;b:=b+a; end;
if (a='size;') then begin; o:=o or factNames_Size;b:=b+a; end;
if (a='perm;') then begin; o:=o or factNames_Perm;b:=b+a; end;
if (a='create;') then begin; o:=o or factNames_Create;b:=b+a; end;
if (a='modify;') then begin; o:=o or factNames_Modify;b:=b+a; end;
goto f1;
f2:
con.mlst:=o;
changeMlstFacts:=b;
End;

Function ready2xfer:Boolean;
Begin;
if con.start then begin;
  ready2xfer:=false;
  exit;
  end;
ready2xfer:=true;
if (con.data<>0) then con.start:=true;
if (GetTimePast(con.time)<2*60) then exit;
xClose(con.fileH);
xDirClose(con.fileH);
con.fileH:=0;
pipeLineClose(con.data);
con.data:=0;
con.start:=false;
con.stat:=3;
sendResp('425 failed to open data connection');
End;

Procedure eatOptions(var c:String);
Var a,b:String;
Begin;
b:=c;
a:=getWord(b);
if (copy(a,1,1)='-') and (b<>'') then c:=b;
End;

Function createUnique(var fn:String):LongInt;
Label f1;
Var
  old:String;
  i:LongInt;
Begin;
old:=fn;
f1:
fn:=old+BStr(Random($7fffffff))+'-'+BStr(Random($7fffffff))+'-'+BStr(Random($7fffffff));
i:=xCreate(fn);
if (I=8) then goto f1;
if (i=0) then xSetRight(fn,con.uid,xRights_OwnRead+xRights_OwnWrite+xRights_AnyRead);
createUnique:=i;
End;


Function quote2unix(a:string;quote:Boolean):String;
Label f1,f2;
Var
  ab:array[0..1] of byte absolute a;
  i:LongInt;
Begin;
for i:=ab[0]+1 to 255 do ab[i]:=0;
if (ab[1]=$2f) and (ab[3]=$3a) and (ab[4]=$2f) then a:=copy(a,2,255);
for i:=1 to ab[0] do case ab[i] of
  $2f:ab[i]:=$5c;
  $5c:ab[i]:=$2f;
  $00:ab[i]:=$20;
  $ff:ab[i]:=$20;
  $22:if quote then ab[i]:=0;
  end;
f1:
i:=pos(#0,a);
if (i<1) then goto f2;
a:=copy(a,1,i-1)+'""'+copy(a,i+1,255);
goto f1;
f2:
if quote then a:='"'+a+'"';
quote2unix:=a;
End;

Function GetFileInfo(a:String;var d:xDirEntryRec):Boolean;
Label f1,f2;
Var
  b:String;
  f:xFile;
Begin;
GetFileInfo:=True;
BugOS_SetOwnerInfo(con.uid);
xChDir(con.path);
b:=xFileName(a,1);
a:=kicsi(xFileName(a,2)+xFileName(a,3));
if (b='') then b:='.\';
if (xDirOpen(f,b)<>0) then goto f1;
f2:
if (xDirRead(f,d)<>0) then goto f1;
if (d.name='') then goto f1;
if (kicsi(d.name)<>a) then goto f2;
GetFileInfo:=False;
f1:
xDirClose(f);
End;


Procedure doCmds;
Label f1;
Var
  i,o,p:LongInt;
  a,b:String;
Begin;
f1:
if (con.ibufP>=con.ibufS) then begin;
  i:=inputBufMax;
  if (pipeLineRecv(con.pipe,con.ibufD,i)<>0) then i:=0;
  con.ibufS:=i;
  con.ibufP:=0;
  if (i<1) then begin;
    pipeLineStats(con.pipe,i,o,p);
    if (i<>0) then exit;
    con.stat:=0;
    WriteLn('connection lost with '+ipAddr2string(con.adr)+' '+BStr(con.prt));
    exit;
    end;
  con.time:=CurrentTime;
  end;
inc(con.ibufP);
i:=con.ibufD[con.ibufP];
if (i=10) then goto f1;
if (i<>13) then begin;
  con.cmd:=con.cmd+chr(i);
  goto f1;
  end;
b:=con.cmd;
con.cmd:='';
a:=kicsi(getWord(b));
if (a='quit') then begin;
  sendResp('221 ftp server says goodbye');
  con.stat:=0;
  exit;
  end;
if (a='help') then begin;
  sendResp('214-the following commands are recognized (* means unimplemented)');
  sendResp('   USER   PORT   RETR   ALLO   DELE   SITE   XMKD   CDUP   FEAT');
  sendResp('   PASS   PASV   STOR   REST   CWD    STAT   RMD    XCUP   OPTS');
  sendResp('   ACCT*  TYPE   APPE   RNFR   XCWD   HELP   XRMD   STOU   AUTH');
  sendResp('   REIN   STRU   SMNT*  RNTO   LIST   NOOP   PWD    SIZE   EPSV');
  sendResp('   QUIT   MODE   SYST   ABOR   NLST   MKD    XPWD   MDTM   PORT');
  sendResp('   MSAM*  MRSQ*  MLFL*  MRCP*  MAIL*  MSND*  MSOM*  MACB*  EPRT');
  sendResp('   PBSZ*  PROT*  ADAT*  CCC*   MIC*   CONF*  ENC*   MLST   MLSD');
  sendResp('214 direct comments to postmaster@localhost');
  exit;
  end;
if (a='syst') then begin;
  sendResp('215 BugOS v2.0');
  exit;
  end;
if (a='auth') then begin;
  sendResp('504 unknown security mechanism');
  exit;
  end;
if (a='feat') then begin;
  sendResp('211-extension supported');
  sendResp(' MDTM');
  sendResp(' SIZE');
  sendResp(' REST STREAM');
  sendResp(' SITE CHMOD');
  sendResp(' MLST '+getSupportedFacts);
  sendResp(' TVFS');
  sendResp('211 end');
  exit;
  end;
if (a='stat') then begin;
  sendResp('211-status follows:');
  sendResp('   connection: '+ipAddr2string(con.adr)+' '+BStr(con.prt));
  case con.stat of
    2:a:='authenticating';
    3:a:='command';
    4:a:='receiving';
    5:a:='sending';
    6:a:='directory listing (wide)';
    7:a:='directory listing (short)';
    8:a:='connecting';
    9:a:='directory listing (machine)';
    10:a:='waiting for disconnect';
    else a:='unknown';
    end;
  sendResp('   status: '+a);
  sendResp('211 end of status');
  exit;
  end;
if (a='rein') then begin;
  xClose(con.fileH);
  xDirClose(con.fileH);
  con.fileH:=0;
  pipeLineClose(con.data);
  con.data:=0;
  con.start:=false;
  con.stat:=2;
  con.uid:=GuestUserIDmasking;
  sendResp('220 log in again!');
  con.dataT:=0;
  con.dataS:='';
  exit;
  end;
if (a='user') then begin;
  con.stat:=2;
  con.uid:=GuestUserIDmasking;
  con.dataT:=1;
  con.dataS:=b;
  sendResp('331 give me your password, please');
  exit;
  end;
if (a='pass') then begin;
  if (con.stat<>2) or (con.dataT<>1) then begin;
    sendResp('503 bad sequence of commands; USER first');
    exit;
    end;
  if (authenticateOneUser(con.dataS,b,'ftp with '+ipAddr2string(con.adr)+' '+BStr(con.prt),LoginFlags_accessFtp,con.uid)<>0) then begin;
    WriteLn('authentication failed with '+ipAddr2string(con.adr)+' '+BStr(con.prt)+' '+con.dataS);
    con.time:=CurrentTime;
    con.stat:=10;
    exit;
    end;
  con.stat:=3;
  con.path:=defaultPath+':\';
  sendResp('230 logged in successfully');
  con.dataT:=0;
  con.dataS:='';
  exit;
  end;
if (a='abor') then begin;
  xDirClose(con.fileH);
  xClose(con.fileH);
  con.fileH:=0;
  if (con.data<>0) then begin;
    con.stat:=3;
    sendResp('426 connection closed; transfer ABORted');
    end;
  pipeLineClose(con.data);
  con.data:=0;
  con.start:=false;
  sendResp('226 ABOR command successful');
  exit;
  end;

if (con.stat<>3) then begin;
  sendResp('500 command unrecognized: "'+a+'" "'+b+'"');
  exit;
  end;
if (con.data<>0) then begin;
  pipeLineStats(con.data,i,o,p);
  if (i=0) then begin;
    pipeLineClose(con.data);
    con.data:=0;
    con.start:=false;
    end;
  end;

if (a='pasv') then begin;
  pipeLineClose(con.data);
  con.data:=0;
  con.start:=false;
  a[0]:=#6;
  move(addrDat[sizeof(addrDat)-3],i,sizeof(i));
  move(i,a[1],sizeof(i));
  WriteWordMSB(a[5],portDat);
  b:='';
  for i:=1 to 6 do b:=b+','+BStr(ord(a[i]));
  b:=copy(b,2,255);
  sendResp('227 entering passive mode ('+b+')');
  exit;
  end;
if (a='epsv') then begin;
  pipeLineClose(con.data);
  con.data:=0;
  con.start:=false;
  if isAddressIPv4mask(addrDat) then a:='1' else a:='2';
  a:='|'+a+'|'+ipAddr2string(addrDat)+'|'+BStr(portDat)+'|';
  sendResp('227 entering extended passive mode ('+a+')');
  exit;
  end;
if (a='port') then begin;
  pipeLineClose(con.data);
  con.data:=0;
  con.start:=false;
  b:=b+',';
  a:='';
  for o:=1 to 6 do begin;
    i:=pos(',',b);
    a:=a+chr(BVal(copy(b,1,i-1)));
    b:=copy(b,i+1,255);
    end;
  i:=ReadWordMSB(a[5]);
  a:=IPv4addressPrefix+copy(a,1,4);
  TCPbeginConnect(con.data,65536,a[1],i);
  con.stat:=8;
  WriteLn('connecting to '+ipAddr2string(a[1])+' '+BStr(i)+'...');
  exit;
  end;
if (a='eprt') then begin;
  pipeLineClose(con.data);
  con.data:=0;
  con.start:=false;
  a:=copy(b,2,255);
  a:=copy(a,pos('|',a)+1,255);
  i:=pos('|',a);
  b:=copy(a,1,i-1);
  a:=copy(a,i+1,255);
  a:=copy(a,1,pos('|',a)-1);
  i:=BVal(a);
  string2ipAddr(b,a[1]);
  TCPbeginConnect(con.data,65536,a[1],i);
  con.stat:=8;
  WriteLn('connecting to '+ipAddr2string(a[1])+' '+BStr(i)+'...');
  exit;
  end;

if (a='stou') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  i:=createUnique(b);
  if (i<>0) then begin;
    sendResp('550 error: '+xGetErrorName(i));
    con.rest:=0;
    exit;
    end;
  con.rest:=0;
  b:=quote2unix(b,false);
  a:='stor';
  end;
if (a='appe') then begin;
  b:=quote2unix(b,false);
  if GetFileInfo(b,ntry) then begin;
    sendResp('550 file not found');
    con.rest:=0;
    exit;
    end;
  if (con.rest=0) then con.rest:=ntry.size;
  b:=quote2unix(b,false);
  a:='stor';
  end;
if (a='stor') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  if (xCreate(b)=0) then xSetRight(b,con.uid,xRights_OwnRead+xRights_OwnWrite+xRights_AnyRead);
  i:=xOpen(con.fileH,b,xGenFilMod_rw);
  if (i<>0) then begin;
    xClose(con.fileH);
    con.fileH:=0;
    sendResp('550 error: '+xGetErrorName(i));
    con.rest:=0;
    exit;
    end;
  i:=xFileSize(con.fileH);
  if (con.rest>i) then con.rest:=i;
  con.fileP:=con.rest;
  xSeek(con.fileH,con.fileP);
  a:=xFileName(b,2)+xFileName(b,3);
  sendResp('150 opening binary mode data connection for '+a);
  con.stat:=4;
  con.rest:=0;
  exit;
  end;
if (a='retr') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  i:=xOpen(con.fileH,b,xGenFilMod_r);
  if (i<>0) then begin;
    xClose(con.fileH);
    con.fileH:=0;
    sendResp('550 error: '+xGetErrorName(i));
    con.rest:=0;
    exit;
    end;
  con.fileP:=con.rest;
  con.fileS:=xFileSize(con.fileH);
  xSeek(con.fileH,con.fileP);
  a:=xFileName(b,2)+xFileName(b,3);
  sendResp('150 opening binary mode data connection for '+a+' ('+BStr(con.fileS)+' bytes)');
  con.stat:=5;
  con.rest:=0;
  exit;
  end;
if (a='list') then begin;
  con.rest:=0;
  eatOptions(b);
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  if (b='') then b:='.\';
  i:=xDirOpen(con.fileH,b);
  if (i<>0) then begin;
    xDirClose(con.fileH);
    con.fileH:=0;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('150 data connection already open; transfer starting');
  con.stat:=6;
  exit;
  end;
if (a='nlst') then begin;
  con.rest:=0;
  eatOptions(b);
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  if (b='') then b:='.\';
  i:=xDirOpen(con.fileH,b);
  if (i<>0) then begin;
    xDirClose(con.fileH);
    con.fileH:=0;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('150 data connection already open; transfer starting');
  con.stat:=7;
  exit;
  end;
if (a='mlsd') then begin;
  con.rest:=0;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  if (b='') then b:='.\';
  i:=xDirOpen(con.fileH,b);
  if (i<>0) then begin;
    xDirClose(con.fileH);
    con.fileH:=0;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('150 data connection already open; transfer starting');
  con.stat:=9;
  exit;
  end;

if (a='pwd') or (a='xpwd') then begin;
  sendResp('257 '+quote2unix(con.path,true)+' is the current directory');
  exit;
  end;
if (a='cdup') or (a='xcup') then begin; a:='cwd';b:='..'; end;
if (a='cwd') or (a='xcwd') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  i:=xChDir(b);
  a:=xGetDir;
  if (i<>0) then begin;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  con.path:=a;
  sendResp('250 '+quote2unix(con.path,true)+' is the current directory');
  exit;
  end;
if (a='mkd') or (a='xmkd') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  i:=xMkDir(b);
  xChDir(b);
  a:=xGetDir;
  if (i<>0) then begin;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('257 '+quote2unix(a,true)+' directory created');
  exit;
  end;
if (a='rmd') or (a='xrmd') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  xChDir(b);
  a:=xGetDir;
  xChDir(con.path);
  i:=xRmDir(b);
  if (i<>0) then begin;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('250 '+quote2unix(a,true)+' directory erased');
  exit;
  end;
if (a='dele') then begin;
  b:=quote2unix(b,false);
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  i:=xErase(b);
  if (i<>0) then begin;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('250 '+quote2unix(b,true)+' file erased');
  exit;
  end;
if (a='rnfr') then begin;
  b:=quote2unix(b,false);
  con.dataT:=2;
  con.dataS:=b;
  sendResp('350 use RNTO to rename it to');
  exit;
  end;
if (a='rnto') then begin;
  b:=quote2unix(b,false);
  if (con.dataT<>2) then begin;
    sendResp('503 bad sequence of commands; RNFR first');
    exit;
    end;
  BugOS_SetOwnerInfo(con.uid);
  xChDir(con.path);
  a:=con.dataS;
  con.dataT:=0;
  con.dataS:='';
  i:=xRename(a,b);
  if (i<>0) then begin;
    sendResp('550 error: '+xGetErrorName(i));
    exit;
    end;
  sendResp('250 file renamed');
  exit;
  end;
if (a='size') then begin;
  b:=quote2unix(b,false);
  if GetFileInfo(b,ntry) then begin;
    sendResp('550 file not found');
    exit;
    end;
  sendResp('213 '+BStr(ntry.size));
  exit;
  end;
if (a='mdtm') then begin;
  b:=quote2unix(b,false);
  if GetFileInfo(b,ntry) then begin;
    sendResp('550 file not found');
    exit;
    end;
  sendResp('213 '+getDateForMDTM(ntry.modified));
  exit;
  end;
if (a='mlst') then begin;
  b:=quote2unix(b,false);
  if GetFileInfo(b,ntry) then begin;
    sendResp('550 file not found');
    exit;
    end;
  sendResp('250-listing '+b);
  sendResp(' '+getDirListingExt+' '+b);
  sendResp('250 end');
  exit;
  end;
if (a='rest') then begin;
  p:=BVal(b);
  if (BStr(p)<>b) or (p<0) then begin;
    sendResp('501 illegal parameter');
    exit;
    end;
  sendResp('350 restarting at '+BStr(p)+'. send STORe or RETRieve');
  con.rest:=p;
  exit;
  end;

if (a='site') then begin;
  a:=kicsi(getWord(b));
  if (a='chmod') then begin;
    a:=copy(getWord(b)+'000',1,3);
    b:=quote2unix(b,false);
    if GetFileInfo(b,ntry) then begin;
      sendResp('550 file not found');
      exit;
      end;
    o:=setUnixRights(a[1]);
    i:=setUnixRights(a[2]) or setUnixRights(a[3]);
    i:=(i shl 3) or o;
    i:=xSetRight(b,ntry.owner,i);
    if (i<>0) then begin;
      sendResp('550 error: '+xGetErrorName(i));
      exit;
      end;
    sendResp('253 rights changed');
    exit;
    end;
  sendResp('500 command unrecognized: "site '+a+'" "'+b+'"');
  exit;
  end;
if (a='opts') then begin;
  a:=kicsi(getWord(b));
  if (a='mlst') then begin;
    a:=changeMlstFacts(b);
    sendResp('200 MLST OPTS '+a);
    exit;
    end;
  sendResp('500 command unrecognized: "opts '+a+'" "'+b+'"');
  exit;
  end;
if (a='mode') then begin;
  b:=kicsi(b);
  if (b<>'s') then begin;
    sendResp('504 only the stream mode is supported');
    exit;
    end;
  sendResp('200 mode is stream');
  exit;
  end;
if (a='stru') then begin;
  b:=kicsi(b);
  if (b<>'f') then begin;
    sendResp('504 only the file structure is supported');
    exit;
    end;
  sendResp('200 structure is file');
  exit;
  end;
if (a='type') then begin;
  b:=kicsi(b);
  if (copy(b,1,1)='a') then o:=1;
  if (copy(b,1,1)='i') then o:=2;
  case o of
    1:a:='ascii';
    2:a:='image';
    else begin;
      sendResp('504 only the ascii and image types are supported');
      exit;
      end;
    end;
  sendResp('200 type is '+a);
  exit;
  end;
if (pos('|'+a+'|','|pbsz|prot|adat|ccc|mic|conf|enc|')<>0) then begin;
  sendResp('503 secure control connection required for command');
  exit;
  end;
if (pos('|'+a+'|','|macb|acct|msam|mrsq|mlfl|mrcp|smnt|mail|msnd|msom|')<>0) then begin;
  sendResp('502 command understood but not (yet) implemented');
  exit;
  end;
if (a='noop') then begin;
  sendResp('220 no operation completed successfully');
  exit;
  end;
if (a='allo') then begin;
  sendResp('200 okay; command is meaningless');
  exit;
  end;

sendResp('500 command unrecognized: "'+a+'" "'+b+'"');
End;


Label f1,f2,f3;
Var
  t:xtText;
  i,o,p:LongInt;
  a,b:String;
Begin;
if (GetTimePast(con.time)>5*60) then begin;
  WriteLn('connection timed out with '+ipAddr2string(con.adr)+' '+BStr(con.prt));
  sendResp('421 timeout!');
  doConn:=True;
  exit;
  end;
doConn:=False;
case con.stat of
  5:begin; {tx}
    doCmds;
    if ready2xfer then exit;
    i:=sizeof(buf);
    pipeLineRecv(con.data,buf,i);
    pipeLineStats(con.data,i,o,p);
    if (i=0) then begin;
      a:='; remote closed connection';
      goto f1;
      end;
    p:=p and (-512);
    if (p<512) then exit;
    if (con.fileP and $1ff<>0) then p:=512-(con.fileP and $1ff);
    i:=con.fileS-con.fileP;
    if (p>i) then p:=i;
    if (p>sizeof(buf)) then p:=sizeof(buf);
    if (i<1) then begin;
      a:='; '+BStr(con.fileP)+' bytes sent';
      goto f2;
      end;
    BugOS_SetOwnerInfo(con.uid);
    i:=xBlockRead(con.fileH,buf,p);
    if (i<>0) then begin;
      a:='; error: '+xGetErrorName(i);
      goto f1;
      end;
    pipeLineSend(con.data,buf,p);
    lastSent:=TCPprocessId;
    inc(con.fileP,p);
    con.time:=CurrentTime;
    end;
  4:begin; {rx}
    doCmds;
    if ready2xfer then exit;
    pipeLineStats(con.data,i,p,o);
    if (i=0) then begin;
      if (p>0) then goto f3;
      a:='; '+BStr(con.fileP)+' bytes received';
      goto f2;
      end;
    p:=p and (-512);
    if (p<512) then exit;
    if (con.fileP and $1ff<>0) then p:=512-(con.fileP and $1ff);
    f3:
    if (p>sizeof(buf)) then p:=sizeof(buf);
    if (pipeLineRecv(con.data,buf,p)<>0) then p:=0;
    BugOS_SetOwnerInfo(con.uid);
    i:=xBlockWrite(con.fileH,buf,p);
    if (i<>0) then begin;
      a:='; error: '+xGetErrorName(i);
      goto f1;
      end;
    inc(con.fileP,p);
    con.time:=CurrentTime;
    end;
  6:begin; {list}
    doCmds;
    if ready2xfer then exit;
    i:=sizeof(buf);
    pipeLineRecv(con.data,buf,i);
    pipeLineStats(con.data,i,o,p);
    if (i=0) then begin;
      a:='; remote closed connection';
      f1:
      BugOS_SetOwnerInfo(con.uid);
      con.rest:=0;
      con.stat:=3;
      xTruncate(con.fileH);
      xClose(con.fileH);
      xDirClose(con.fileH);
      con.fileH:=0;
      pipeLineClose(con.data);
      con.data:=0;
      con.start:=false;
      sendResp('426 transfer failed'+a);
      exit;
      end;
    if (p<512) then exit;
    BugOS_SetOwnerInfo(con.uid);
    i:=xDirRead(con.fileH,ntry);
    if (i<>0) then begin;
      a:='; error: '+xGetErrorName(i);
      goto f1;
      end;
    if (ntry.name='') then begin;
      a:='';
      f2:
      BugOS_SetOwnerInfo(con.uid);
      con.rest:=0;
      con.stat:=3;
      xTruncate(con.fileH);
      xClose(con.fileH);
      xDirClose(con.fileH);
      con.fileH:=0;
      pipeLineClose(con.data);
      con.data:=0;
      con.start:=false;
      sendResp('226 transfer completed'+a);
      exit;
      end;
    sendDataStr(getDirListingNorm+' ');
    sendDataStr(ntry.name);
    sendDataStr(#13#10);
    end;
  7:begin; {nlst}
    doCmds;
    if ready2xfer then exit;
    i:=sizeof(buf);
    pipeLineRecv(con.data,buf,i);
    pipeLineStats(con.data,i,o,p);
    if (i=0) then begin;
      a:='; remote closed connection';
      goto f1;
      end;
    if (p<258) then exit;
    BugOS_SetOwnerInfo(con.uid);
    i:=xDirRead(con.fileH,ntry);
    if (i<>0) then begin;
      a:='; error: '+xGetErrorName(i);
      goto f1;
      end;
    if (ntry.name='') then begin;
      a:='';
      goto f2;
      end;
    sendDataStr(ntry.name);
    sendDataStr(#13#10);
    end;
  9:begin; {mlsd}
    doCmds;
    if ready2xfer then exit;
    i:=sizeof(buf);
    pipeLineRecv(con.data,buf,i);
    pipeLineStats(con.data,i,o,p);
    if (i=0) then begin;
      a:='; remote closed connection';
      goto f1;
      end;
    if (p<512) then exit;
    BugOS_SetOwnerInfo(con.uid);
    i:=xDirRead(con.fileH,ntry);
    if (i<>0) then begin;
      a:='; error: '+xGetErrorName(i);
      goto f1;
      end;
    if (ntry.name='') then begin;
      a:='';
      goto f2;
      end;
    sendDataStr(getDirListingExt+' ');
    sendDataStr(ntry.name);
    sendDataStr(#13#10);
    end;
  3:doCmds; {commands}
  2:doCmds; {authenticate}
  8:begin; {connect}
    if TCPlookConnected(con.data,a,i,o) then begin;
      if (con.data<>0) then exit;
      sendResp('425 failed to open data connection');
      con.stat:=3;
      exit;
      end;
    sendResp('220 PORT command successful');
    con.start:=true;
    con.stat:=3;
    end;
  1:begin; {init}
    if TCPlookConnected(con.pipe,con.adr,con.prt,i) then begin;
      doConn:=(con.pipe=0);
      exit;
      end;
    WriteLn('connection accepted from '+ipAddr2string(con.adr)+' '+BStr(con.prt)+' to '+BStr(i));
    if (i<>portCmd) then begin;
      doConn:=True;
      p:=FindOneAddress(con.adr,conN);
      if (p=0) then exit;
      if (ConnectionDat^[p].data<>0) then exit;
      ConnectionDat^[p].data:=con.pipe;
      ConnectionDat^[p].start:=true;
      con.pipe:=0;
      exit;
      end;
    i:=FindOneAddress(con.adr,conN);
    if (i<>0) then begin;
      sendResp('421 only one simultaneous connection allowed!');
      doConn:=True;
      exit;
      end;
    BugOS_SetOwnerInfo(0);
    if (xtOpen(t,'c:\system\loginScreen.text',true)=0) then begin;
      while not xtEOF(t) do begin;
        a:=xtReadLn(t,255);
        sendResp('220-'+a);
        end;
      xtClose(t);
      end;
    sendResp('220 ftp server ready!');
    con.stat:=2;
    con.dataT:=0;
    con.cmd:='';
    con.uid:=GuestUserIDmasking;
    con.data:=0;
    con.start:=false;
    con.mlst:=$ff;
    end;
  10:begin; {wait for disconnect}
    if (GetTimePast(con.time)<4) then exit;
    sendResp('530 not logged in!');
    sendResp('421 disconnecting...');
    con.stat:=0;
    end;
  0:begin; doConn:=True;exit; end; {disconnect}
  else begin; doConn:=True;exit; end;
  end;
End;
