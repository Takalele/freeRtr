Function doConn(var con:OneConnectionRecord;conN:LongInt):Boolean;
Var
  buf:array[1..16*1024] of byte;
  ntry:xDirEntryRec;

Procedure SendResp(a:String);
Begin;
pipeLineSend(con.pipe,a[1],length(a));
con.time:=CurrentTime;
End;

Procedure BeginRequest;
Label f1;
Begin;
BugOS_SetOwnerInfo(0);
if (con.request<>'') then exit;
f1:
con.request:=BStr(random($7fffffff))+'.'+BStr(random($7fffffff))+'.'+BStr(random($7fffffff));
if (xCreate(TempPath+con.request+RequestExt)<>0) then goto f1;
xCreate(TempPath+con.request+ResponseExt);
xOpen(con.fileH,TempPath+con.request+RequestExt,xGenFilMod_rw);
End;

Procedure WriteRequest(typ:byte;nam,dat:String);
Var i:LongInt;
Begin;
i:=xFilePos(con.fileH);
con.fileP:=i;
inc(i,6+length(dat)+length(nam));
xBlockWrite(con.fileH,i,sizeof(i));
xBlockWrite(con.fileH,typ,sizeof(typ));
xBlockWrite(con.fileH,nam,length(nam)+1);
xBlockWrite(con.fileH,dat[1],length(dat));
End;

Function FinishRequest(a:String):Boolean;
Var i:LongInt;
Begin;
FinishRequest:=False;
if (copy(con.ntry,length(con.ntry)-length(a)+1,255)<>a) then exit;
xBlockWrite(con.fileH,con.line[1],length(con.line));
i:=xFilePos(con.fileH)-length(a);
xSeek(con.fileH,con.fileP);
xBlockWrite(con.fileH,i,sizeof(i));
xSeek(con.fileH,i);
xTruncate(con.fileH);
con.ntry:='';
con.line:='';
FinishRequest:=True;
End;

Function GetFileInfo(a:String;var d:xDirEntryRec):Boolean;
Label f1,f2;
Var
  b:String;
  f:xFile;
Begin;
GetFileInfo:=True;
b:=xFileName(a,1);
a:=kicsi(xFileName(a,2)+xFileName(a,3));
if (b='') then b:='.\';
if (xDirOpen(f,b)<>0) then goto f1;
f2:
if (xDirRead(f,d)<>0) then goto f1;
if (d.name='') then goto f1;
if (kicsi(d.name)<>a) then goto f2;
GetFileInfo:=False;
f1:
xDirClose(f);
End;

Function GetValueOfOneField(s,a:String):String;
Label f1,f2;
Var
  i:Byte;
  c:Char;
Begin;
GetValueOfOneField:='';
a:=Kicsi(a);
i:=pos(a,Kicsi(s));
if (i=0) then Exit;
delete(s,1,i);
i:=pos('=',s);
if (i=0) then Exit;
delete(s,1,i);
if (copy(s,1,1)='"') then begin;
  delete(s,1,1);
  i:=pos('"',s);
  a:=copy(s,1,i-1);
  goto f2;
  end;
a:='';
f1:
if (s='') then goto f2;
c:=s[1];
delete(s,1,1);
if (c in [' ',';']) then goto f2;
a:=a+c;
goto f1;
f2:
GetValueOfOneField:=a;
End;


Function DecodeOneRangeReqLine(a:String;var bg,ed:LongInt):Boolean;

function testNum(var s:string;var n:LongInt):Boolean;
Label vege;
begin;
testNum:=True;
if (s='') then begin; n:=0;goto vege; end;
n:=BVal(s);
if (BStr(n)<>s) then exit;
vege:
testNum:=False;
end;

Var
  b:String;
  i:LongInt;
Begin;
DecodeOneRangeReqLine:=False;
i:=pos('-',a);
if (i=0) then exit;
b:=copy(a,i+1,255);
a:=copy(a,1,i-1);
if testNum(a,bg) then exit;
if testNum(b,ed) then exit;
if (bg<0) and (ed<0) then exit;
DecodeOneRangeReqLine:=True;
End;

Function AuthenticateUser(a:String):Boolean;
Label f1,f2;
Var
  b,c,d:String;
  i:LongInt;
  t:xtText;
Begin;
AuthenticateUser:=True;
b:=kicsi(decodeBase64(con.authed));
i:=pos(':',b);
c:=copy(b,1,i-1);
d:=copy(b,i+1,255);
if (xtOpen(t,a+'authenticate.data',true)<>0) then exit;
f1:
repeat
  if xtEOF(t) then goto f2;
  a:=kicsi(xtReadln(t,255));
  until (a<>'');
b:=kicsi(xtReadln(t,255));
if (a<>c) then goto f1;
if (b=d) then AuthenticateUser:=False;
f2:
xtClose(t);
End;


Procedure SendError(tit,hdr,bod:String);
Var a:String;
Begin;
BugOS_SetOwnerInfo(0);
xClose(con.fileH);
xErase(TempPath+con.request+RequestExt);
xErase(TempPath+con.request+ResponseExt);
con.request:='';
con.fileH:=0;
SendResp('HTTP/1.1 '+tit+#13#10);
SendResp('Server: '+ProggyName+' for BugOS'#13#10);
SendResp('Content-Length: '+BStr(Length(bod))+#13#10);
SendResp('Content-Type: text/html'#13#10);
if (hdr<>'') then begin; SendResp(hdr);SendResp(#13#10); end;
if (con.connTp=1) then a:='Keep-Alive' else a:='Close';
SendResp('Connection: '+a+#13#10);
if (con.connTp=1) then SendResp('Keep-Alive: TimeOut=60, Max=25'#13#10);
SendResp(#13#10);
SendResp(bod);
if (con.connTp=1) then con.stat:=2 else con.stat:=0;
con.url:='';
End;

Procedure sendFile(typ:String;sendRange:Boolean);
Var
  sz,bg,ed:LongInt;
  a:String;
Begin;
sz:=xFileSize(con.fileH);
if con.range then begin; bg:=con.rangeBeg;ed:=con.rangeEnd; end else begin; bg:=0;ed:=0; end;
if (ed=0) then ed:=sz;
if (bg>ed) then bg:=ed;
inc(ed);
if (ed>sz) then ed:=sz;
xSeek(con.fileH,bg);
con.fileP:=bg;
con.fileS:=ed;
SendResp('HTTP/1.1 200 ok'#13#10);
SendResp('Server: '+ProggyName+' for BugOS'#13#10);
SendResp('Content-Length: '+BStr(ed-bg)+#13#10);
if sendRange then SendResp('Content-Range: bytes '+BStr(bg)+'-'+BStr(ed-1)+'/'+BStr(sz)+#13#10);
SendResp('Content-Type: '+typ+#13#10);
if (con.connTp=1) then a:='Keep-Alive' else a:='Close';
SendResp('Connection: '+a+#13#10);
if (con.connTp=1) then SendResp('Keep-Alive: TimeOut=60, Max=25'#13#10);
SendResp(#13#10);
con.stat:=7;
End;

Procedure openFile(a:String);
Label f1,f2,f3;
Var
  t:xtText;
  f,ff:xFile;
  i,o:LongInt;
  b:string;
  visNtry:record
    year:word;month:word;day:Word;
    hour:word;min:word;sec:Word;
    ipaddr:array[1..16] of char;
    agent:String;
    filler:array[1..228] of char;
    end;

function x(i:longint):string;var a:string;begin; a:=bstr(i);while (length(a)<2) do a:='0'+a;x:=a; end;

function y(d:xDirEntryDateTimeRec):string;begin; y:=x(d.year)+'-'+x(d.month)+'-'+x(d.day)+' '+x(d.hour)+':'+x(d.minute)+':'+x(d.second); end;

function z(i:longint):string;
var a:string;
begin;
a:='';
if (i and xRights_HasRootPriv<>0) then a:=a+'U' else a:=a+'-';
if (i and xRights_Directory<>0) then a:=a+'d' else a:=a+'-';
if (i and xRights_OwnRead<>0) then a:=a+'r' else a:=a+'-';
if (i and xRights_OwnWrite<>0) then a:=a+'w' else a:=a+'-';
if (i and xRights_OwnExec<>0) then a:=a+'x' else a:=a+'-';
if (i and xRights_AnyRead<>0) then a:=a+'R' else a:=a+'-';
if (i and xRights_AnyWrite<>0) then a:=a+'W' else a:=a+'-';
if (i and xRights_AnyExec<>0) then a:=a+'X' else a:=a+'-';
z:=a;
end;


Begin;
b:=copy(kicsi(xFileName(a,3)),2,666);
if (b='code') then if not GetFileInfo(a,ntry) then begin;
  if not hostsListDat[con.hostN].execute then begin;
    SendError('403 forbidden','','<html><body>file execution not allowed!</body></html>');
    exit;
    end;
  BeginRequest;
  WriteRequest(1,'browser',con.clnt);
  WriteRequest(1,'host',hostsListDat[con.hostN].nam);
  a:=con.url;
  kicserel('\','/',a);
  WriteRequest(1,'url',a);
  a[0]:=chr(sizeof(con.adr));
  move(con.adr,a[1],sizeof(con.adr));
  WriteRequest(1,'client',a);
  xClose(con.fileH);
  con.stat:=8;
  inc(con.ibufS);
  BugOS_SetOwnerInfo(0);
  xSetRight(TempPath+con.request+RequestExt,con.hostU,xRights_OwnRead);
  xSetRight(TempPath+con.request+ResponseExt,con.hostU,xRights_OwnRead+xRights_OwnWrite);
  exit;
  end;
if (xOpen(f,a,xGenFilMod_r)=0) then begin;
  xClose(con.fileH);
  con.fileH:=f;
  if not hostsListDat[con.hostN].readFile then begin;
    SendError('403 forbidden','','<html><body>file reading not allowed!</body></html>');
    exit;
    end;
  i:=FindExtension(b);
  if (i=0) then a:='*/*' else a:=MimeTypesDat[i].typ;
  sendFile(a,con.range);
  exit;
  end;
if (xDirOpen(f,a)<>0) then begin;
  f3:
  SendError('404 not found','','<html><body>the requested url not found!</body></html>');
  exit;
  end;
xClose(con.fileH);
if (copy(a,length(a),255)<>'\') then a:=a+'\';
if (xOpen(ff,a+'visitor.data',xGenFilMod_rw)=0) then begin;
  fillchar(visNtry,sizeof(visNtry),0);
  xGetDate(visNtry.year,visNtry.month,visNtry.day);
  xGetTime(visNtry.hour,visNtry.min,visNtry.sec);
  visNtry.agent:=con.clnt;
  move(con.adr,visNtry.ipaddr,sizeof(visNtry.ipaddr));
  xSeek(ff,xFileSize(ff));
  xBlockWrite(ff,visNtry,sizeof(visNtry));
  xClose(ff);
  end;
if (xOpen(con.fileH,a+'autostart.html',xGenFilMod_r)=0) then begin;
  xDirClose(f);
  if not hostsListDat[con.hostN].readFile then begin;
    SendError('403 forbidden','','<html><body>file reading not allowed!</body></html>');
    exit;
    end;
  sendFile('text/html',con.range);
  exit;
  end;
if not hostsListDat[con.hostN].dirList then begin;
  xDirClose(f);
  SendError('403 forbidden','','<html><body>directory listing not allowed!</body></html>');
  exit;
  end;
BeginRequest;
xClose(con.fileH);
if (xtOpen(t,TempPath+con.request+ResponseExt,false)<>0) then goto f3;
xtWriteLn(t,'<html>');
xtWriteLn(t,'<head>');
xtWriteLn(t,'<title>directory listing</title>');
xtWriteLn(t,'</head>');
xtWriteLn(t,'<body>');
xtWrite(t,'<h2>directory listing of '+hostsListDat[con.hostN].nam+' - ');
a:='\'+con.url;
if (copy(a,length(a),255)<>'\') then a:=a+'\';
Kicserel('\','/',a);
xtWrite(t,a);
xtWriteLn(t,'</h2><br>');
xtWriteLn(t,'<table border="1">');
xtWriteLn(t,'<tr>');
xtWriteLn(t,'  <td><b>created</b></td>');
xtWriteLn(t,'  <td><b>modified</b></td>');
xtWriteLn(t,'  <td><b>owner</b></td>');
xtWriteLn(t,'  <td><b>rights</b></td>');
xtWriteLn(t,'  <td><b>size</b></td>');
xtWriteLn(t,'  <td><b>name</b></td>');
xtWriteLn(t,'  </tr>');
b:=copy(a,1,length(a)-1);
o:=length(b);
for i:=1 to o do if (b[i]='/') then o:=i;
b:=copy(b,1,o);
if (b<>'') then begin;
  xtWriteLn(t,'<tr>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td><a href="/">root directory</a></td>');
  xtWriteLn(t,'  </tr>');
  xtWriteLn(t,'<tr>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWriteLn(t,'  <td>-</td>');
  xtWrite(t,'  <td><a href="');
  xtWrite(t,b);
  xtWriteLn(t,'">parent directory</a></td>');
  xtWriteLn(t,'  </tr>');
  end;
f1:
if (xDirRead(f,ntry)<>0) then goto f2;
if (ntry.name='') then goto f2;
xtWriteLn(t,'<tr>');
xtWriteLn(t,'  <td>'+y(ntry.created)+'</td>');
xtWriteLn(t,'  <td>'+y(ntry.modified)+'</td>');
xtWriteLn(t,'  <td>'+conv2hex(ntry.owner)+'</td>');
xtWriteLn(t,'  <td>'+z(ntry.rights)+'</td>');
xtWriteLn(t,'  <td>'+BStr(ntry.size)+'</td>');
xtWrite(t,'  <td><a href="');
b:=ntry.name;
if (ntry.rights and xRights_Directory<>0) then b:=b+'/';
xtWrite(t,a);
xtWrite(t,b);
xtWrite(t,'">');
xtWrite(t,b);
xtWriteLn(t,'</a></td>');
xtWriteLn(t,'  </tr>');
goto f1;
f2:
xDirClose(f);
xtWriteLn(t,'</table>');
xtWriteLn(t,'<i>generated by <b>'+ProggyName+'</b>.</i>');
xtWriteLn(t,'</body>');
xtWriteLn(t,'</html>');
xtClose(t);
if (xOpen(con.fileH,TempPath+con.request+ResponseExt,xGenFilMod_r)<>0) then goto f3;
con.range:=false;
sendFile('text/html',false);
End;

Procedure doParam;
Var
  a:String;
  i:LongInt;
Begin;
a:=con.line;
con.line:='';
if (a='') then exit;
i:=pos('=',a);
WriteRequest(2,copy(a,1,i-1),copy(a,i+1,255));
End;


Label f1,f2,f3;
Var
  i,o,p:LongInt;
  a,b,c:String;
Begin;
doConn:=False;
if (con.stat=7) then begin;
  pipeLineStats(con.pipe,i,o,p);
  if (i=0) then goto f1;
  p:=p and (-512);
  if (p<512) then exit;
  if (con.fileP and $1ff<>0) then p:=512-(con.fileP and $1ff);
  o:=con.fileS-con.fileP;
  if (o<1) then begin;
    BugOS_SetOwnerInfo(0);
    xClose(con.fileH);
    xErase(TempPath+con.request+RequestExt);
    xErase(TempPath+con.request+ResponseExt);
    con.request:='';
    con.fileH:=0;
    if (con.connTp=1) then con.stat:=2 else con.stat:=0;
    con.url:='';
    con.time:=CurrentTime;
    exit;
    end;
  if (o>sizeof(buf)) then o:=sizeof(buf);
  if (p>o) then p:=o;
  if (xBlockRead(con.fileH,buf,p)<>0) then goto f1;
  pipeLineSend(con.pipe,buf,p);
  lastSent:=TCPprocessId;
  inc(con.fileP,p);
  con.time:=CurrentTime;
  exit;
  end;
if (GetTimePast(con.time)>60) then begin;
  f2:
  con.connTp:=0;
  SendError('404 not found','','<html><body>the requested url not found!</body></html>');
  f1:
  con.stat:=0;
  doConn:=True;
  exit;
  end;
if (con.stat=0) then goto f1;
if (con.ibufP>=con.ibufS) then begin;
  i:=inputBufMax;
  if (pipeLineRecv(con.pipe,con.ibufD,i)<>0) then i:=0;
  con.ibufS:=i;
  con.ibufP:=0;
  if (i<1) then begin;
    pipeLineStats(con.pipe,i,o,p);
    if (i<>0) then exit;
    goto f1;
    end;
  con.time:=CurrentTime;
  end;
case con.stat of
  0:goto f1; {disconnect}
  1:begin; {init}
    if TCPlookConnected(con.pipe,con.adr,con.prt,i) then begin;
      doConn:=(con.pipe=0);
      exit;
      end;
    if (CountAddress(con.adr)>limitHost) then goto f1;
    WriteLn('connection accepted from '+ipAddr2string(con.adr)+' '+BStr(con.prt)+' to '+BStr(i));
    con.stat:=2;
    con.url:='';
    con.ibufS:=0;
    con.ibufP:=0;
    end;
  2:while (con.ibufS>con.ibufP) do begin; {command}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    if (i<>$20) then begin;
      con.url:=con.url+chr(i);
      if (length(con.url)>32) then goto f3;
      continue;
      end;
    a:=kicsi(con.url);
    o:=0;
    if (a='get') then o:=1;
    if (a='put') then o:=1;
    if (a='post') then o:=1;
    if (o=0) then begin;
      f3:
      con.connTp:=0;
      SendError('400 bad request','','<html><body>request has bad syntax!</body></html>');
      goto f1;
      end;
    con.url:='';
    con.host:='';
    con.clnt:='';
    con.line:='';
    con.bond:='';
    con.quoS:=0;
    con.range:=false;
    con.authed:='';
    con.connTp:=0;
    con.stat:=3;
    exit;
    end;
  3:while (con.ibufS>con.ibufP) do begin; {url}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    if (con.quoS<>0) then begin;
      inc(con.quoS);
      con.quoB[con.quoS]:=i;
      if (con.quoS<3) then continue;
      con.quoS:=0;
      move(con.quoB,a,5);
      con.url:=con.url+chr(BVal(a));
      continue;
      end;
    if (i=$0d) then goto f3;
    if (i=$0a) then goto f3;
    if (i=$20) then begin; con.stat:=4;exit; end;
    if (i=$2b) then i:=$20;
    if (i=$25) then begin;
      con.quoS:=1;
      con.quoB[0]:=3;
      con.quoB[1]:=36;
      continue;
      end;
    if (i=$3f) then begin;
      BeginRequest;
      con.stat:=10;
      exit;
      end;
    con.url:=con.url+chr(i);
    end;
  4:while (con.ibufS>con.ibufP) do begin; {protocol}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    con.host:=con.host+chr(i);
    if (length(con.host)<10) then continue;
    a:=kicsi(con.host);
    a[6]:='1';
    a[8]:='1';
    if (a<>'http/1.1'#13#10) then goto f3;
    con.stat:=5;
    a:=kicsi(con.url);
    if (copy(a,1,8)='https://') then a:='http://'+copy(a,9,255);
    if (copy(a,1,7)<>'http://') then begin; con.host:='';con.url:=a;exit; end;
    a:=copy(a,8,255);
    i:=pos('/',a);
    if (i=0) then goto f3;
    con.host:=copy(a,1,i-1);
    con.url:=copy(a,i,255);
    exit;
    end;
  5:while (con.ibufS>con.ibufP) do begin; {lines}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    if (i=13) then continue;
    if (i<>10) then begin; con.line:=con.line+chr(i);continue; end;
    if (con.ibufP<con.ibufS) then if (con.ibufD[con.ibufP+1]=$20) then continue;
    a:=con.line;
    con.line:='';
    if (a='') then begin;
      con.ntry:=#2;
      if (con.bond<>'') then begin;
        BeginRequest;
        con.bond:=#13#10'--'+con.bond;
        con.stat:=11;
        exit;
        end;
      inc(con.ibufS);
      con.stat:=6;
      exit;
      end;
    i:=pos(':',a);
    if (i=0) then continue;
    b:=' '+copy(a,i+1,255)+' ';
    a:=kicsi(copy(a,1,i-1));
    kicserel('  ',' ',b);
    b:=copy(b,2,length(b)-2);
    if (a='host') then begin;
      con.host:=b;
      continue;
      end;
    if (a='connection') then begin;
      i:=0;b:=Kicsi(b);
      if (pos('keep-alive',b)<>0) then con.connTp:=1;
      continue;
      end;
    if (a='content-type') then begin;
      b:=GetValueOfOneField(b,'boundary');
      con.bond:=b;
      continue;
      end;
    if (a='user-agent') then begin;
      con.clnt:=b;
      continue;
      end;
    if (a='range') then begin;
      b:=GetValueOfOneField(b,'bytes');
      con.range:=DecodeOneRangeReqLine(b,con.rangeBeg,con.rangeEnd);
      continue;
      end;
    if (a='authorization') then begin;
      con.authed:=copy(b,pos(' ',b)+1,255);
      continue;
      end;
    end;
  6:begin; {begin action}
    dec(con.ibufS);
    c:=con.url;
    b:='';
    while (c<>'') do begin;
      i:=pos('/',c);
      if (i=0) then begin;
        if (c='.') or (c='..') then begin; c:=c+'\';continue; end;
        b:=b+c;
        break;
        end;
      a:=copy(c,1,i-1);
      c:=copy(c,i+1,255);
      if (a='') then continue;
      if (a='.') then continue;
      if (a<>'..') then begin; b:=b+a+'\';continue; end;
      o:=0;
      for i:=1 to length(b)-1 do if (b[i]='\') then o:=i;
      b:=copy(b,1,o);
      end;
    con.url:=b;
    a:=con.host;
    if (copy(a,1,1)='[') then begin;
      i:=pos(']',a);
      a:=copy(a,2,i-2);
      end else begin;
      i:=pos(':',a);
      if (i<>0) then a:=copy(a,1,i-1);
      end;
    i:=FindHostName(a);
    if (i=0) then goto f2;
    con.hostN:=i;
    con.hostU:=hostsListDat[i].userid;
    a:=hostsListDat[i].pat;
    con.host:=a;
    if (copy(a,1,1)=':') then begin;
      a:=copy(a,2,255);
      if hostsListDat[i].execute then a:=a+con.url;
      SendError('302 found','Location: '+a,'<html><body>moved <a href="'+a+'">here</a></body></html>');
      exit;
      end;
    BugOS_SetOwnerInfo(con.hostU);
    if hostsListDat[i].authentic then if AuthenticateUser(a) then begin;
      a:='WWW-Authenticate: Basic realm="'+hostsListDat[i].nam+'"';
      SendError('401 unauthorized',a,'<html><body>authorization required</a></body></html>');
      exit;
      end;
    openFile(con.host+con.url);
    end;
  10:while (con.ibufS>con.ibufP) do begin; {parameter}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    if (con.quoS<>0) then begin;
      inc(con.quoS);
      con.quoB[con.quoS]:=i;
      if (con.quoS<3) then continue;
      con.quoS:=0;
      move(con.quoB,a,5);
      con.line:=con.line+chr(BVal(a));
      continue;
      end;
    if (i=$20) then begin; doParam;con.stat:=4;exit; end;
    if (i=$2b) then i:=$20;
    if (i=$25) then begin;
      con.quoS:=1;
      con.quoB[0]:=3;
      con.quoB[1]:=36;
      continue;
      end;
    if (i=$26) then begin; doParam;continue; end;
    con.line:=con.line+chr(i);
    end;
  11:while (con.ibufS>con.ibufP) do begin; {form-header}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    if (i=13) then continue;
    if (i<>10) then begin; con.line:=con.line+chr(i);continue; end;
    a:=con.line;
    if (a='') then begin;
      WriteRequest(ord(con.ntry[1]),copy(con.ntry,2,255),'');
      con.line:='';
      con.ntry:=con.bond+'12345678';
      con.stat:=12;
      exit;
      end;
    if (con.ibufP<con.ibufS) then if (con.ibufD[con.ibufP+1]=$20) then continue;
    con.line:='';
    i:=pos(':',a);
    if (i=0) then continue;
    b:=' '+copy(a,i+1,255)+' ';
    a:=kicsi(copy(a,1,i-1));
    kicserel('  ',' ',b);
    b:=copy(b,2,length(b)-2);
    if (a='content-disposition') then begin;
      a:=GetValueOfOneField(b,'name');
      if (a<>'') then begin; con.ntry:=#2+a;continue; end;
      a:=GetValueOfOneField(b,'filename');
      if (a<>'') then begin; con.ntry:=#3+a;continue; end;
      continue;
      end;
    end;
  12:while (con.ibufS>con.ibufP) do begin; {form-data}
    inc(con.ibufP);
    i:=con.ibufD[con.ibufP];
    con.line:=con.line+chr(i);
    con.ntry:=copy(con.ntry+chr(i),2,255);
    if (length(con.line)>=128) then begin;
      xBlockWrite(con.fileH,con.line[1],length(con.line));
      con.line:='';
      end;
    if (i<>10) then continue;
    if FinishRequest(con.bond+#13#10) then begin; con.stat:=11;exit; end;
    if FinishRequest(con.bond+'--'#13#10) then begin; inc(con.ibufS);con.stat:=6;exit; end;
    end;
  8:begin; {exec-wait}
    p:=0;
    for o:=1 to ConnectionNum do if (ConnectionDat^[o].stat=9) then begin;
      inc(p);
      if (p<limitCgis) then continue;
      con.time:=CurrentTime;
      pipeLineStats(con.pipe,i,o,p);
      if (i=0) then goto f1;
      exit;
      end;
    con.fileP:=CurrentTime;
    BugOS_SetOwnerInfo(0);
    a:=con.host+con.url;
    xChDir(xFileName(a,1));
    BugOS_SetOwnerInfo(con.hostU);
    xExecBgnd(a,TempPath+con.request,con.process);
    con.stat:=9;
    end;
  9:begin; {exec}
    pipeLineStats(con.pipe,i,o,p);
    if (i=0) then goto f1;
    con.time:=CurrentTime;
    if (GetTimePast(con.fileP)>TimeOutCgi) then goto f2;
    if BugOS_ProcessExists(con.process) then exit;
    dec(con.ibufS);
    con.process:=0;
    BugOS_SetOwnerInfo(0);
    if (xOpen(con.fileH,TempPath+con.request+ResponseExt,xGenFilMod_r)<>0) then goto f2;
    i:=xFileSize(con.fileH);
    if (i=0) then goto f2;
    p:=0;
    xBlockRead(con.fileH,p,1);
    xBlockRead(con.fileH,a,1);
    xBlockRead(con.fileH,a[1],length(a));
    if (p=2) then begin;
      SendError('302 found','Location: '+a,'<html><body>moved <a href="'+a+'">here</a></body></html>');
      exit;
      end;
    if (p=3) then begin;
      i:=FindExtension(a);
      if (i=0) then a:='*/*' else a:=MimeTypesDat[i].typ;
      p:=4;
      end;
    if (p<>4) then goto f2;
    con.range:=true;
    con.rangeBeg:=xFilePos(con.fileH);
    con.rangeEnd:=0;
    sendFile(a,false);
    end;
  else begin; doConn:=True;exit; end;
  end;
End;
