Procedure doTrans(var con:OneOutgoingRecord);
Var
  buf:array[1..1024*8] of byte;
  f,ff:xFile;
  t,tt:xtText;

Procedure FindNextTx(var a:String);
Label f1,f2;
Var
  d:xDirEntryRec;
  i:LongInt;
Begin;
if (xDirOpen(f,tempPath)<>0) then exit;
f1:
if (xDirRead(f,d)<>0) then begin; a:='';goto f2; end;
a:=kicsi(d.name);
if (a='') then goto f2;
if (xFileName(a,3)<>MsgdatExt) then goto f1;
a:=xFileName(a,2);
if (xOpen(ff,tempPath+a+MsgdatExt,xGenFilMod_rw)<>0) then goto f1;
i:=xFilesize(ff);
xClose(ff);
if (i<1) then goto f1;
f2:
xDirClose(f);
End;

Procedure Copy2localUser(u:LongInt);
Var
  a,b,c:String;
  i,p,s:LongInt;
  t,tt:xtText;

Procedure doAutoreply;
Label err;
Begin;
if (xtOpen(t,tempPath+con.fileN+RemoteExt,true)<>0) then b:='' else begin;
  b:=xtReadLn(t,255);
  xtClose(t);
  end;
if (b='') then exit;
if (xtOpen(tt,usersListDat[u].path+LocalAutoreplyFile,true)<>0) then exit;
CreateFile(TempPath,MsgdatExt,c);
xCreate(TempPath+c+LocalExt);
xCreate(TempPath+c+RemoteExt);
if (xtOpen(t,TempPath+c+RemoteExt,false)<>0) then goto err;
a:=usersListDat[u].emil;
xtWriteLn(t,'');
xtWriteLn(t,b);
xtClose(t);
if (xtOpen(t,TempPath+c+MsgdatExt,false)<>0) then goto err;
xtWriteLn(t,'Received: from autoreply@localhost with internal via internal');
xtWriteLn(t,'          by '+ipAddr2string(serverAddr)+' (helo '+DomainName+');');
xtWriteLn(t,'          '+GetDateForHeader);
xtWriteLn(t,'          for '+b);
xtWriteLn(t,'          (envelope-from )');
xtWriteLn(t,'Date: '+GetDateForHeader);
xtWriteLn(t,'To: <'+b+'>');
while not xtEOF(tt) do begin;
  while not xtEOL(tt) do xtWrite(t,xtRead(tt,255));
  xtWriteLn(t,xtReadLn(tt,255));
  end;
xtClose(t);
xtClose(tt);
exit;
err:
xtClose(tt);
xErase(TempPath+c+MsgdatExt);
xErase(TempPath+c+LocalExt);
xErase(TempPath+c+RemoteExt);
End;

Function doForward:Boolean;
Var bb:Boolean;
Begin;
doForward:=False;
if (xtOpen(tt,usersListDat[u].path+LocalForwardFile,true)<>0) then exit;
if (xtOpen(t,tempPath+con.fileN+RemoteExt,false)<>0) then begin; xtClose(tt);exit; end;
bb:=false;
while not xtEOF(tt) do begin;
  a:=xtReadLn(tt,255);
  if (a='@') then bb:=true;
  if EmailAddrTestSyntax(a) then continue;
  xtWriteLn(t,a);
  end;
xtClose(t);
xtClose(tt);
doForward:=bb;
End;

Begin;
if (u<1) or (u>usersListNum) then exit;
doAutoreply;
if doForward then exit;
CreateFile(usersListDat[u].path,LocalMessageFile,a);
a:=usersListDat[u].path+a+LocalMessageFile;
if (xOpen(ff,a,xGenFilMod_rw)<>0) then exit;
s:=xFileSize(f);
p:=0;
xSeek(f,0);
while (p<s) do begin;
  i:=s-p;
  if (i>sizeof(buf)) then i:=sizeof(buf);
  xBlockRead(f,buf,i);
  xBlockWrite(ff,buf,i);
  inc(p,i);
  end;
xClose(ff);
xSetRight(a,usersListDat[u].uid,xRights_OwnRead);
End;

Procedure encloseTextFile(a:String);
Label f1,f2;
Begin;
if (xtOpen(tt,a,true)<>0) then exit;
f1:
if xtEOF(tt) then begin;
  xtClose(tt);
  exit;
  end;
if xtEOL(tt) then begin;
  a:=xtReadLn(tt,255);
  xtWriteLn(t,a);
  end;
f2:
if xtEOL(tt) then goto f1;
a:=xtRead(tt,128);
xtWrite(t,a);
goto f2;
End;

Procedure readConn;
Label f1;
Var
  i,o:LongInt;
  a,b:String;
Begin;
if (con.cmd<>'') then exit;
if (GetTimePast(con.time)>5*60) then begin;
  pipeLineClose(con.pipe);
  con.cmd:='connection timed out!';
  con.rsp:=999;
  WriteLn('connection timed out with '+ipAddr2string(con.adr)+' '+BStr(con.prt));
  exit;
  end;
a:=con.rxb;
f1:
if (con.ibufP>=con.ibufS) then begin;
  i:=inputBufMax;
  if (pipeLineRecv(con.pipe,con.ibufD,i)<>0) then i:=0;
  con.ibufS:=i;
  con.ibufP:=0;
  if (i<1) then begin;
    con.rxb:=a;
    pipeLineStats(con.pipe,i,o,o);
    if (i<>0) then exit;
    pipeLineClose(con.pipe);
    con.cmd:='connection lost!';
    con.rsp:=999;
    WriteLn('connection lost with '+ipAddr2string(con.adr)+' '+BStr(con.prt));
    exit;
    end;
  con.time:=CurrentTime;
  end;
inc(con.ibufP);
i:=con.ibufD[con.ibufP];
if (i=10) then goto f1;
if (i<>13) then begin;
  a:=a+chr(i);
  goto f1;
  end;
b:=copy(a,1,3);
i:=BVal(b);
if (BStr(i)<>b) then begin; a:='';goto f1; end;
if (copy(a,4,1)<>' ') then begin; a:='';goto f1; end;
con.rsp:=i;
con.cmd:=a;
con.rxb:='';
End;

Procedure writeConn(a:String);
Begin;
a:=a+#13#10;
pipeLineSend(con.pipe,a[1],length(a));
con.time:=CurrentTime;
End;


Procedure PutErrMsg(act:String);
Begin;
pipeLineClose(con.pipe);
con.stat:=3;
xtOpen(t,tempPath+con.fileN+LocalExt,false);
xtWriteLn(t,'  domain: '+con.nam);
xtWriteLn(t,'  address: '+ipAddr2string(con.adr)+' '+BStr(con.prt));
xtWriteLn(t,'  response: '+con.cmd);
xtWriteLn(t,'  action: '+act);
xtWriteLn(t,'  error: bad response received');
xtWriteLn(t,'');
xtClose(t);
End;


Label err,vege,del;
Var
  a,b:String;
  i,o,p:LongInt;
Begin;
case con.stat of
  0:begin; {free}
    if (ConnectionNum<>0) then exit;
    if (GetTimePast(con.time)<60) then exit;
    con.time:=CurrentTime;
    FindNextTx(con.fileN);
    if (con.fileN='') then exit;
    if (xtOpen(t,tempPath+con.fileN+MsgdatExt,true)<>0) then goto del;
    p:=0;
    repeat
      a:=kicsi(xtReadLn(t,255));
      if (copy(a,1,9)='received:') then inc(p);
      until (a='');
    xtClose(t);
    if (p>128) then begin; b:='hop count reached maximum!';goto err; end;
    if (xOpen(f,tempPath+con.fileN+MsgdatExt,xGenFilMod_r)<>0) then goto del;
    if (xtOpen(t,tempPath+con.fileN+LocalExt,true)<>0) then begin; xClose(f);goto del; end;
    while not xtEOF(t) do begin;
      a:=xtReadLn(t,255);
      i:=pos(' ',a);
      a:=copy(a,1,i-1);
      Copy2localUser(BVal(a));
      end;
    xtClose(t);
    xClose(f);
    if (xOpen(f,tempPath+con.fileN+LocalExt,xGenFilMod_rw)<>0) then goto del;
    xSeek(f,0);
    xTruncate(f);
    xClose(f);
    con.stat:=1;
    con.currRcpt:=0;
    end;
  1:begin; {next recipient}
    inc(con.currRcpt);
    if (xtOpen(t,tempPath+con.fileN+RemoteExt,true)<>0) then goto del;
    con.source:=xtReadLn(t,255);
    b:='';
    for o:=1 to con.currRcpt do b:=xtReadLn(t,255);
    xtClose(t);
    con.target:=b;
    if (b='') then goto vege;
    if (xOpen(f,tempPath+con.fileN+LocalExt,xGenFilMod_rw)<>0) then goto del;
    i:=xFileSize(f);
    con.msgPos:=i;
    xSeek(f,i);
    a:=#13#10'recipient: <';
    xBlockWrite(f,a[1],length(a));
    xBlockWrite(f,b[1],length(b));
    a:='>'#13#10;
    xBlockWrite(f,a[1],length(a));
    xClose(f);
    if (relayServer<>'') then begin;
      con.servers:=relayServer;
      con.stat:=3;
      exit;
      end;
    a:=EmailAddrGetDomain(con.target);
    DNSresolvePut(3,a);
    con.stat:=2;
    end;
  2:begin; {resolve MX hosts}
    i:=DNSresolveGet(a,b);
    if (i and $7f<>3) then exit;
    if (kicsi(a)<>kicsi(EmailAddrGetDomain(con.target))) then exit;
    con.servers:=b;
    if (b<>'') then begin;
      con.stat:=3;
      exit;
      end;
    xtOpen(t,tempPath+con.fileN+LocalExt,false);
    xtWriteLn(t,'  error: no mail exchange host for domain!');
    xtWriteLn(t,'');
    xtClose(t);
    con.stat:=1;
    end;
  3:begin; {next server}
    a:=con.servers;
    if (a='') then begin;
      con.stat:=1;
      exit;
      end;
    i:=pos(#0,a);
    if (i<1) then i:=666;
    con.servers:=copy(a,i+1,255);
    a:=copy(a,1,i-1);
    con.nam:=kicsi(a);
    con.retry:=0;
    DNSresolvePut(1,a);
    con.stat:=4;
    end;
  4:begin; {resolve address of host}
    i:=DNSresolveGet(a,b);
    if (i and $7f<>1) then exit;
    if (kicsi(a)<>con.nam) then exit;
    if (i and $80<>0) then begin;
      xtOpen(t,tempPath+con.fileN+LocalExt,false);
      xtWriteLn(t,'  domain: '+con.nam);
      xtWriteLn(t,'  error: address not found!');
      xtWriteLn(t,'');
      xtClose(t);
      con.stat:=3;
      exit;
      end;
    move(b,con.adr,sizeof(con.adr));
    con.prt:=serverPort;
    WriteLn('connecting to '+ipAddr2string(con.adr)+' '+BStr(con.prt));
    TCPbeginConnect(con.pipe,65536,con.adr,con.prt);
    con.stat:=5;
    end;
  5:begin; {connecting}
    if not TCPlookConnected(con.pipe,a,i,o) then begin;
      WriteLn('connected, local side is '+ipAddr2string(a)+' '+BStr(i)+'...');
      con.time:=CurrentTime;
      con.cmd:='';
      con.rxb:='';
      con.stat:=6;
      exit;
      end;
    if (con.pipe<>0) then exit;
    inc(con.retry);
    if (con.retry<16) then begin;
      WriteLn('failed, connecting to '+ipAddr2string(con.adr)+' '+BStr(con.prt));
      TCPbeginConnect(con.pipe,65536,con.adr,con.prt);
      exit;
      end;
    xtOpen(t,tempPath+con.fileN+LocalExt,false);
    xtWriteLn(t,'  domain: '+con.nam);
    xtWriteLn(t,'  address: '+ipAddr2string(con.adr)+' '+BStr(con.prt));
    xtWriteLn(t,'  error: failed to open connection!');
    xtWriteLn(t,'');
    xtClose(t);
    con.stat:=3;
    end;
  6:begin; {welcome message}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp div 100<>2) then begin;
      PutErrMsg('waiting for welcome message');
      exit;
      end;
    writeConn('HELO '+domainName);
    con.cmd:='';
    con.stat:=7;
    if (relayUserPass<>#0#0) then con.stat:=14;
    end;
  7:begin; {helo response}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp div 100<>2) then begin;
      PutErrMsg('waiting for response of HELO command');
      exit;
      end;
    a:=con.source;
    EmailAddrEnQuote(a);
    writeConn('MAIL FROM:<'+a+'>');
    con.cmd:='';
    con.stat:=8;
    end;
  8:begin; {mail from response}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp div 100<>2) then begin;
      PutErrMsg('waiting for response of MAIL FROM command');
      exit;
      end;
    a:=con.target;
    EmailAddrEnQuote(a);
    writeConn('RCPT TO:<'+a+'>');
    con.cmd:='';
    con.stat:=9;
    end;
  9:begin; {rcpt to response}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp div 100<>2) then begin;
      PutErrMsg('waiting for response of RCPT TO command');
      exit;
      end;
    writeConn('DATA');
    con.cmd:='';
    con.stat:=10;
    end;
  10:begin; {data response}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp<>354) then begin;
      PutErrMsg('waiting for response of DATA command');
      exit;
      end;
    if (xtOpen(con.fileH,tempPath+con.fileN+MsgdatExt,true)<>0) then begin;
      pipeLineClose(con.pipe);
      goto del;
      end;
    con.cmd:='';
    con.stat:=11;
    con.sawNL:=False;
    end;
  11:begin; {sending data}
    con.time:=CurrentTime;
    readConn;
    if (con.cmd<>'') then begin;
      xtClose(con.fileH);
      PutErrMsg('sending message body');
      exit;
      end;
    pipeLineStats(con.pipe,i,o,p);
    if (p<300) then exit;
    if xtEOF(con.fileH) then begin;
      xtClose(con.fileH);
      if con.sawNL then a:='.'#13#10 else a:=#13#10'.'#13#10;
      pipeLineSend(con.pipe,a[1],length(a));
      con.stat:=12;
      exit;
      end;
    if xtEOL(con.fileH) then begin;
      a:=xtReadLn(con.fileH,200)+#13#10;
      if con.sawNL then if (copy(a,1,1)='.') then a:='.'+a;
      pipeLineSend(con.pipe,a[1],length(a));
      con.sawNL:=True;
      exit;
      end;
    a:=xtRead(con.fileH,200);
    if con.sawNL then if (copy(a,1,1)='.') then a:='.'+a;
    pipeLineSend(con.pipe,a[1],length(a));
    con.sawNL:=False;
    end;
  12:begin; {data ack}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp<>250) then begin;
      PutErrMsg('waiting for message acknowledgement');
      exit;
      end;
    writeConn('QUIT');
    con.cmd:='';
    con.stat:=13;
    end;
  13:begin; {quit}
    readConn;
    if (con.cmd='') then exit;
    pipeLineClose(con.pipe);
    if (xOpen(f,tempPath+con.fileN+LocalExt,xGenFilMod_rw)<>0) then goto del;
    xSeek(f,con.msgPos);
    xTruncate(f);
    xClose(f);
    con.stat:=1;
    end;
  14:begin; {auth command}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp div 100<>2) then begin;
      PutErrMsg('waiting for response of HELO command');
      exit;
      end;
    writeConn('AUTH PLAIN');
    con.cmd:='';
    con.stat:=15;
    end;
  15:begin; {auth data}
    readConn;
    if (con.cmd='') then exit;
    if (con.rsp div 100<>3) then begin;
      PutErrMsg('waiting for response of AUTH command');
      exit;
      end;
    writeConn(encodeBase64(relayUserPass));
    con.cmd:='';
    con.stat:=7;
    end;
  else begin;
    xtClose(con.fileH);
    pipeLineClose(con.pipe);
    fillchar(con,sizeof(con),0);
    con.time:=CurrentTime;
    con.stat:=0;
    end;
  end;
Exit;
err:
if (xtOpen(t,tempPath+con.fileN+LocalExt,false)<>0) then goto del;
if (xtOpen(tt,tempPath+con.fileN+RemoteExt,true)<>0) then begin; xtClose(t);goto del; end;
a:=xtReadLn(tt,255);
xtSetPos(t,0);
xtWriteLn(t,'');
p:=0;
while not xtEOF(tt) do begin;
  a:=xtReadLn(tt,255);
  xtWriteLn(t,a+':');
  inc(p);
  end;
xtClose(tt);
xtWriteLn(t,'  error: '+b);
xtTruncate(t);
xtClose(t);
if (p<1) then goto del;
vege:
if (xtOpen(t,tempPath+con.fileN+RemoteExt,true)<>0) then goto del;
b:=xtReadLn(t,255);
xtClose(t);
if (b='') then goto del;
if (xtOpen(t,tempPath+con.fileN+LocalExt,true)<>0) then goto del;
if xtEOF(t) then begin; xtClose(t);goto del; end;
xtClose(t);
CreateFile(tempPath,MsgdatExt,a);
xCreate(tempPath+a+LocalExt);
xCreate(tempPath+a+RemoteExt);
if (xtOpen(t,tempPath+a+RemoteExt,false)<>0) then goto del;
xtWriteLn(t,'');
xtWriteLn(t,b);
xtClose(t);
if (xtOpen(t,tempPath+a+MsgdatExt,false)<>0) then goto del;
xtWriteLn(t,'Received: from deliver@localhost with internal via internal');
xtWriteLn(t,'          by '+ipAddr2string(serverAddr)+' (helo '+DomainName+');');
xtWriteLn(t,'          '+GetDateForHeader);
xtWriteLn(t,'          for '+b);
xtWriteLn(t,'          (envelope-from )');
xtWriteLn(t,'From: "mailer daemon" <mailer-daemon@'+DomainName+'>');
xtWriteLn(t,'To: <'+b+'>');
xtWriteLn(t,'Subject: failure notice');
xtWriteLn(t,'Date: '+GetDateForHeader);
b:=BStr(random($7fffffff))+'='+GetDateForFiles+'='+BStr(random($7fffffff));
xtWriteLn(t,'MIME-Version: 1.0');
xtWriteLn(t,'Content-Type: multipart/mixed; boundary="'+b+'"');
xtWriteLn(t,'Message-ID: <'+b+'@'+DomainName+'>');
xtWriteLn(t,'');
xtWriteLn(t,'this is a message in mime format!');
xtWriteLn(t,'');
xtWriteLn(t,'--'+b);
xtWriteLn(t,'Content-type: text/plain; charset="us-ascii"');
xtWriteLn(t,'Content-Transfer-Encoding: 7bit');
xtWriteLn(t,'');
xtWriteLn(t,'hello!');
xtWriteLn(t,'');
xtWriteLn(t,'this message was automatically generated at');
xtWriteLn(t,DomainName+' because the enclosed mail was not');
xtWriteLn(t,'delivered to the following recipients:');
encloseTextFile(tempPath+con.fileN+LocalExt);
xtWriteLn(t,'--'+b);
xtWriteLn(t,'Content-Type: message/rfc822');
xtWriteLn(t,'Content-Transfer-Encoding: 7bit');
xtWriteLn(t,'');
encloseTextFile(tempPath+con.fileN+MsgdatExt);
xtWriteLn(t,'--'+b+'--');
xtClose(t);
del:
xErase(tempPath+con.fileN+MsgdatExt);
xErase(tempPath+con.fileN+LocalExt);
xErase(tempPath+con.fileN+RemoteExt);
fillchar(con,sizeof(con),0);
con.time:=-99999;
con.stat:=0;
End;
