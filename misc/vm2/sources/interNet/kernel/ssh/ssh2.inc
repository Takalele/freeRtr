Procedure sendDisconnectPacket(var con:OneConnectionRecord;cod:LongInt;str:String);
Var pck:OnePacketRecord;
Begin;
add2packetBegin(pck,1);
add2packetInteger(pck,cod);
add2packetString(pck,str);
add2packetString(pck,'');
sendPacket(con,pck);
con.stat:=0;
con.err:=str;
End;

Procedure doSendingPacket(var con:OneConnectionRecord);
Label f1;
Var
  pck1,pck2:OnePacketRecord;
  i,o,p:LongInt;
Begin;
p:=con.ChanCur+1;
if (p>con.ChanNum) then begin;
  if (con.ChanNum<1) then begin;
    if BugOS_ProcessExists(con.proc) then exit;
    sendDisconnectPacket(con,11,'application closing');
    exit;
    end;
  p:=1;
  end;
con.ChanCur:=p;
if (con.ChanDat[p].stat<>1) then exit;
if (con.ChanDat[p].Adjust>LocalWindowSize div 2) then begin;
  add2packetBegin(pck1,93);
  add2packetInteger(pck1,con.ChanDat[p].remID);
  i:=con.ChanDat[p].Adjust;
  if (i>LocalWindowSize) then i:=LocalWindowSize;
  add2packetInteger(pck1,i);
  sendPacket(con,pck1);
  con.ChanDat[p].Adjust:=0;
  end;
i:=con.ChanDat[p].MaxPck;
if (i>con.ChanDat[p].Window) then i:=con.ChanDat[p].Window;
if (i<1) then exit;
if (pipeLineRecv(con.ChanDat[p].pipe,pck2,i)<>0) then i:=0;
if (i<1) then begin;
  pipeLineStats(con.ChanDat[p].pipe,o,i,i);
  if (o<>0) then exit;
  pipeLineClose(con.ChanDat[p].pipe);
  add2packetBegin(pck1,97);
  add2packetInteger(pck1,con.ChanDat[p].remID);
  sendPacket(con,pck1);
  move(con.ChanDat[con.ChanNum],con.ChanDat[p],sizeof(con.ChanDat[p]));
  fillchar(con.ChanDat[con.ChanNum],sizeof(con.ChanDat[con.ChanNum]),0);
  dec(con.ChanNum);
  exit;
  end;
dec(con.ChanDat[p].Window,i);
add2packetBegin(pck1,94);
add2packetInteger(pck1,con.ChanDat[p].remID);
add2packetBinHdr(pck1,pck2,i);
sendPacket(con,pck1);
End;

Procedure processAnyPacket(var con:OneConnectionRecord;pck:OnePacketRecord);
Label f1;
Var
  a,b:String;
  i,o,p:LongInt;
Begin;
p:=1;
case pck.d[1] of
  94:begin; {connection data}
    o:=FindOneLocalConnectID(con,get4packetInteger(p,pck));
    if (o<1) then exit;
    if (con.ChanDat[o].stat<>1) then exit;
    get4packetBinHdr(p,pck,pck,i);
    inc(con.ChanDat[o].Adjust,i);
    pipeLineSend(con.ChanDat[o].pipe,pck,i);
    exit;
    end;
  93:begin; {channel window adjust}
    o:=FindOneLocalConnectID(con,get4packetInteger(p,pck));
    if (o<1) then exit;
    i:=con.ChanDat[o].Window+get4packetInteger(p,pck);
    if (i<1) or (i>RemoteWindowSize) then i:=RemoteWindowSize;
    con.ChanDat[o].Window:=i;
    end;
  94:begin; {channel extended data}
    o:=FindOneLocalConnectID(con,get4packetInteger(p,pck));
    if (o<1) then exit;
    if (con.ChanDat[o].stat<>1) then exit;
    get4packetInteger(p,pck);
    get4packetBinHdr(p,pck,pck,i);
    inc(con.ChanDat[o].Adjust,i);
    pipeLineSend(con.ChanDat[o].pipe,pck,i);
    exit;
    end;
  96,97:begin; {channel eof, close}
    p:=FindOneLocalConnectID(con,get4packetInteger(p,pck));
    if (p<1) then exit;
    pipeLineClose(con.ChanDat[p].pipe);
    add2packetBegin(pck,97);
    add2packetInteger(pck,con.ChanDat[p].remID);
    sendPacket(con,pck);
    move(con.ChanDat[con.ChanNum],con.ChanDat[p],sizeof(con.ChanDat[p]));
    fillchar(con.ChanDat[con.ChanNum],sizeof(con.ChanDat[con.ChanNum]),0);
    dec(con.ChanNum);
    exit;
    end;
  90:begin; {channel open}
    get4packetString(p,pck);
    i:=get4packetInteger(p,pck);
    add2packetBegin(pck,92);
    add2packetInteger(pck,i);
    add2packetInteger(pck,1);
    add2packetString(pck,'forbidden');
    add2packetString(pck,'');
    sendPacket(con,pck);
    exit;
    end;
  1:begin; {disconnect}
    con.stat:=0;
    get4packetInteger(p,pck);
    a:=get4packetString(p,pck);
    con.err:='remote wants disconnect; '+a;
    exit;
    end;
  2:begin; {ignore}
    exit;
    end;
  3:begin; {unimplemented}
    get4packetInteger(p,pck);
    con.err:='remote says unimplemented';
    exit;
    end;
  4:begin; {debug}
    get4packetBoolean(p,pck);
    a:=get4packetString(p,pck);
    con.err:='debug message; '+a;
    exit;
    end;
  5:begin; {service request}
    a:=get4packetString(p,pck);
    con.err:='service request: '+a;
    exit;
    end;
  6:begin; {service accept}
    a:=get4packetString(p,pck);
    con.err:='service accept: '+a;
    exit;
    end;
  80:begin; {global request}
    add2packetBegin(pck,82);
    sendPacket(con,pck);
    exit;
    end;
  else begin;
    con.err:='unknown packet type: '+BStr(pck.d[1]);
    exit;
    end;
  end;
End;




Procedure makeDummyRandomPacket(con:OneConnectionRecord;var pck:OnePacketRecord);
Var
  i,o:LongInt;
  b:Byte;
Begin;
add2packetBegin(pck,2);
o:=random($100)+$10;
add2packetInteger(pck,o);
for i:=1 to o do begin;
  b:=random($100);
  add2packetBinary(pck,b,sizeof(b));
  end;
End;

Procedure makeKeyExchangeInit(con:OneConnectionRecord;var pck:OnePacketRecord);
Var
  a,b:String;
  i,o:LongInt;
Begin;
add2packetBegin(pck,20);
add2packetBinary(pck,con.cokieL,sizeof(con.cokieL));
b:='';
for i:=1 to 64 do begin;
  a:=GetKeyXchgAlgName(i);
  if (a<>'') then b:=b+','+a;
  end;
add2packetString(pck,copy(b,2,255));
b:='';
for i:=1 to 64 do begin;
  a:=GetHostKeyAlgName(i);
  if (a<>'') then b:=b+','+a;
  end;
add2packetString(pck,copy(b,2,255));
b:='';
for i:=1 to length(PreferredCiphers) do b:=b+','+CipherAlgoList[ord(PreferredCiphers[i])].n;
a:=copy(b,2,255);
add2packetString(pck,a);
add2packetString(pck,a);
b:='';
for i:=1 to length(PreferredHashers) do b:=b+','+HasherAlgoList[ord(PreferredHashers[i])].n;
a:=copy(b,2,255);
add2packetString(pck,a);
add2packetString(pck,a);
add2packetString(pck,'none');
add2packetString(pck,'none');
add2packetString(pck,'');
add2packetString(pck,'');
add2packetBoolean(pck,false);
add2packetInteger(pck,0);
End;

Function readKeyExchangeInit(var con:OneConnectionRecord;pck:OnePacketRecord;server:Boolean):Boolean;
Var
  f:xfile;
  ps:LongInt;
  a,b:String;
  i,o,p:LongInt;
  l2r,r2l:string[15];

Procedure swapper(var n1,n2:byte);
Var i:LongInt;
Begin;
i:=n1;
n1:=n2;
n2:=i;
End;

Function doCipher:Boolean;
Begin;
doCipher:=True;
b:=get4packetString(ps,pck);
o:=0;
if server then begin;
  while (o=0) do begin;
    a:=get4listEntry(b);
    if (a='') then exit;
    for i:=1 to length(PreferredCiphers) do begin;
      p:=ord(PreferredCiphers[i]);
      if (a=CipherAlgoList[p].n) then o:=p;
      end;
    end;
  end else begin;
  b:=','+b+',';
  for i:=length(PreferredCiphers) downto 1 do begin;
    p:=ord(PreferredCiphers[i]);
    a:=','+CipherAlgoList[p].n+',';
    if (pos(a,b)<>0) then o:=p;
    end;
  end;
if (o<1) then exit;
doCipher:=False;
End;

Function doHasher:Boolean;
Begin;
doHasher:=True;
b:=get4packetString(ps,pck);
o:=0;
if server then begin;
  while (o=0) do begin;
    a:=get4listEntry(b);
    if (a='') then exit;
    for i:=1 to length(PreferredHashers) do begin;
      p:=ord(PreferredHashers[i]);
      if (a=HasherAlgoList[p].n) then o:=p;
      end;
    end;
  end else begin;
  b:=','+b+',';
  for i:=length(PreferredHashers) downto 1 do begin;
    p:=ord(PreferredHashers[i]);
    a:=','+HasherAlgoList[p].n+',';
    if (pos(a,b)<>0) then o:=p;
    end;
  end;
if (o<1) then exit;
doHasher:=False;
End;

Var guessWasBad:Boolean;
Begin;
readKeyExchangeInit:=True;
con.stat:=0;
guessWasBad:=False;
ps:=17;
con.err:='incompatible key exchange';
b:=get4packetString(ps,pck);o:=0;
if server then begin;
  l2r:='local-->remote';
  r2l:='remote-->local';
  while (o=0) do begin;
    a:=get4listEntry(b);
    if (a='') then exit;
    for i:=1 to 64 do if (GetKeyXchgAlgName(i)=a) then o:=i;
    end;
  end else begin;
  b:=','+b+',';
  for i:=64 downto 1 do begin;
    a:=','+GetKeyXchgAlgName(i)+',';
    if (pos(a,b)<>0) then o:=i;
    end;
  end;
if (o<1) then exit;
con.planKex:=o;
con.planGroup:=0;
for i:=0 to o-1 do if (GetKeyXchgAlgName(i)<>'') then guessWasBad:=True;
con.err:='incompatible server key';
b:=get4packetString(ps,pck);o:=0;
if server then begin;
  while (o=0) do begin;
    a:=get4listEntry(b);
    if (a='') then exit;
    for i:=1 to 64 do if (GetHostKeyAlgName(i)=a) then o:=i;
    end;
  end else begin;
  b:=','+b+',';
  for i:=64 downto 1 do begin;
    a:=','+GetHostKeyAlgName(i)+',';
    if (pos(a,b)<>0) then o:=i;
    end;
  end;
if (o<1) then exit;
con.planSig:=o;
for i:=0 to o-1 do if (GetHostKeyAlgName(i)<>'') then guessWasBad:=True;
con.err:='incompatible '+r2l+' cipher';
if doCipher then exit;
con.planEncRL:=o;
con.err:='incompatible '+l2r+' cipher';
if doCipher then exit;
con.planEncLR:=o;
con.err:='incompatible '+r2l+' hasher';
if doHasher then exit;
con.planMacRL:=o;
con.err:='incompatible '+l2r+' hasher';
if doHasher then exit;
con.planMacLR:=o;
b:=','+get4packetString(ps,pck)+',';
con.err:='incompatible '+r2l+' compression';
if (pos(',none,',b)=0) then exit;
b:=','+get4packetString(ps,pck)+',';
con.err:='incompatible '+l2r+' compression';
if (pos(',none,',b)=0) then exit;
con.err:='';
get4packetString(ps,pck);
get4packetString(ps,pck);
if not get4packetBoolean(ps,pck) then guessWasBad:=False;
con.ChanCur:=guessWasBad;
if guessWasBad then con.err:='misguessed kexreq follows, ignoring';
get4packetInteger(ps,pck);
if server then begin;
  case con.planKex of
    1:con.stat:=4;
    2:con.stat:=6;
    else exit;
    end;
  end else begin;
  swapper(con.planMacLR,con.planMacRL);
  swapper(con.planEncLR,con.planEncRL);
  case con.planKex of
    1:con.stat:=103;
    2:con.stat:=106;
    else exit;
    end;
  end;
readKeyExchangeInit:=False;
End;
