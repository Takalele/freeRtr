Function doConn(var con:OneConnectionRecord;conN:LongInt):Boolean;
Label f1,f2,f3,f4,f5,f6;

Procedure informClient(num:Byte;a:String);
Begin;
if (con.ChanDat[num].stat=1) then exit;
a:=copy(a,1,250)+#13#10;
pipeLineSend(con.ChanDat[num].pipe,a[1],length(a));
End;

Procedure sendErr2clnt;
Begin;
if (con.err='') then exit;
informClient(1,'error:'+con.err);
con.err:='';
End;

Function ReadUserStr(var c:String):Boolean;
Label f1,f2;
Var
  i,o:LongInt;
  b:Byte;
Begin;
ReadUserStr:=True;
if (con.ChanNum<1) then begin; f1:con.stat:=0;exit; end;
pipeLineStats(con.ChanDat[1].pipe,o,i,i);
if (o=0) then goto f1;
f2:
i:=sizeof(b);
if (pipeLineRecv(con.ChanDat[1].pipe,b,i)<>0) then i:=0;
if (i<>sizeof(b)) then begin;
  pipeLineStats(con.ChanDat[1].pipe,o,i,i);
  if (o<>0) then exit;
  goto f1;
  end;
con.time:=CurrentTime;
if (b=8) then begin; c:=copy(c,1,length(c)-1);goto f2; end;
if (b=10) then goto f2;
if (b=13) then begin; ReadUserStr:=False;exit; end;
if (b=27) then begin; c:='';goto f2; end;
c:=c+chr(b);
goto f2;
End;

Function BigNumGenStat(var n:BigNumContextRecord):String;
Begin;
BigNumGenStat:=BStr(BigNumSetedBits(n))+'/'+BStr(BigNumSizeInBits(n));
End;

Var
  pck1,pck2,pck3,pck4:OnePacketRecord;
  grp:OneDiffieHellmanGroup;
  tcpDat1:record
    d:OneTCPcommandHeader;
    u:LongInt;
    end;
  tcpDat2:OneTCPcommandHeader;
  num1,num2,num3:BigNumContextRecord;
  i,o,p,q:LongInt;
  a,b,c:String;
  bb:Byte;
Begin;
if (GetTimePast(con.time)>5*60) then begin;
  sendDisconnectPacket(con,11,'connection timed out');
  doConn:=True;
  exit;
  end;
doConn:=False;
case con.stat of
  77:begin; {normal operation - server}
    if receivePacket(con,pck1) then begin;
      pipeLineStats(con.pipe,i,i,o);
      if (o<1024) then exit;
      doSendingPacket(con);
      exit;
      end;
    q:=1;
    case pck1.d[1] of
      98:begin; {channel request}
        p:=FindOneLocalConnectID(con,get4packetInteger(q,pck1));
        if (p<1) then exit;
        a:=get4packetString(q,pck1);
        i:=get4packetBoolean(q,pck1);
        if (pos('|'+a+'|',safeRequestList)<>0) then begin;
          if (i=0) then exit;
          add2packetBegin(pck1,99);
          add2packetInteger(pck1,con.ChanDat[p].remID);
          sendPacket(con,pck1);
          exit;
          end;
        if (con.ChanDat[p].stat<>0) then goto f5;
        if (a='subsystem') then a:=get4packetString(q,pck1);
        for o:=1 to ListenerNum do begin;
          if (ListenerDat[o].pipe=0) then continue;
          if (ListenerDat[o].name<>a) then continue;
          if (pipeLineCreate(con.ChanDat[p].pipe,ListenerDat[o].proc,ListenerDat[o].wind,false)<>0) then goto f5;
          con.ChanDat[p].port:=o;
          con.ChanDat[p].stat:=1;
          fillchar(tcpDat2,sizeof(tcpDat2),0);
          tcpDat2.cmd:=3;
          move(con.adr,tcpDat2.adr,sizeof(tcpDat2.adr));
          tcpDat2.prt:=con.prt;
          tcpDat2.dat:=ListenerDat[o].port;
          move(tcpDat2,tcpDat1.d,sizeof(tcpDat2));
          tcpDat1.u:=con.userid;
          pipeLineSend(con.ChanDat[p].pipe,tcpDat1,sizeof(tcpDat1));
          if (i=0) then exit;
          add2packetBegin(pck1,99);
          add2packetInteger(pck1,con.ChanDat[p].remID);
          sendPacket(con,pck1);
          exit;
          end;
        f5:
        add2packetBegin(pck1,100);
        add2packetInteger(pck1,con.ChanDat[p].remID);
        sendPacket(con,pck1);
        exit;
        end;
      5:begin; {service request}
        a:=get4packetString(q,pck1);
        if (a<>serviceNameConn) then begin;
          sendDisconnectPacket(con,7,'service not available: '+a);
          exit;
          end;
        add2packetBegin(pck1,6);
        add2packetString(pck1,serviceNameConn);
        sendPacket(con,pck1);
        exit;
        end;
      90:begin; {channel open}
        a:=get4packetString(q,pck1);
        p:=get4packetInteger(q,pck1);
        if (a<>channelNameSess) then begin;
          add2packetBegin(pck1,92);
          add2packetInteger(pck1,p);
          add2packetInteger(pck1,3);
          add2packetString(pck1,'invalid channel type; '+a);
          add2packetString(pck1,'');
          sendPacket(con,pck1);
          exit;
          end;
        if (con.ChanNum>=ChannelMaximum) then begin;
          add2packetBegin(pck1,92);
          add2packetInteger(pck1,p);
          add2packetInteger(pck1,4);
          add2packetString(pck1,'too many open channels, max='+BStr(ChannelMaximum));
          add2packetString(pck1,'');
          sendPacket(con,pck1);
          exit;
          end;
        inc(con.ChanNum);
        o:=con.ChanNum;
        fillchar(con.ChanDat[o],sizeof(con.ChanDat[o]),0);
        con.ChanDat[o].remID:=p;
        i:=get4packetInteger(q,pck1);
        if (i<1) or (i>RemoteWindowSize) then i:=RemoteWindowSize;
        con.ChanDat[o].Window:=i;
        i:=get4packetInteger(q,pck1);
        if (i<1) or (i>$200) then i:=$200;
        con.ChanDat[o].MaxPck:=i;
        con.ChanDat[o].locID:=GenerateLocalConnectID(con);
        add2packetBegin(pck1,91);
        add2packetInteger(pck1,con.ChanDat[o].remID);
        add2packetInteger(pck1,con.ChanDat[o].locID);
        add2packetInteger(pck1,LocalWindowSize);
        add2packetInteger(pck1,$300);
        sendPacket(con,pck1);
        exit;
        end;
      else processAnyPacket(con,pck1);
      end;
    exit;
    end;
  777:begin; {normal operation - client}
    if receivePacket(con,pck1) then begin;
      pipeLineStats(con.pipe,i,i,o);
      if (o<1024) then exit;
      doSendingPacket(con);
      if (con.ChanCur>con.ChanNum) then exit;
      case con.ChanDat[con.ChanCur].stat of
        1:exit;
        2:begin;
          informClient(con.ChanCur,'opening');
          add2packetBegin(pck1,90);
          add2packetString(pck1,channelNameSess);
          add2packetInteger(pck1,con.ChanDat[con.ChanCur].locID);
          add2packetInteger(pck1,LocalWindowSize);
          add2packetInteger(pck1,$300);
          sendPacket(con,pck1);
          con.ChanDat[con.ChanCur].stat:=3;
          exit;
          end;
        3:exit;
        4:begin;
          p:=con.ChanDat[con.ChanCur].port;
          q:=ListenerDat[p].flag;
          if (q and 1<>0) then begin;
            add2packetBegin(pck1,98);
            add2packetInteger(pck1,con.ChanDat[con.ChanCur].remID);
            add2packetString(pck1,'pty-req');
            add2packetBoolean(pck1,false);
            add2packetString(pck1,'xterm');
            add2packetInteger(pck1,80);
            add2packetInteger(pck1,24);
            add2packetInteger(pck1,640);
            add2packetInteger(pck1,480);
            add2packetString(pck1,'');
            sendPacket(con,pck1);
            end;
          add2packetBegin(pck1,98);
          add2packetInteger(pck1,con.ChanDat[con.ChanCur].remID);
          a:=ListenerDat[p].name;
          informClient(con.ChanCur,'requesting:'+a);
          if (q and 2<>0) then begin;
            add2packetString(pck1,'subsystem');
            add2packetBoolean(pck1,true);
            add2packetString(pck1,a);
            end else begin;
            add2packetString(pck1,a);
            add2packetBoolean(pck1,true);
            end;
          sendPacket(con,pck1);
          con.ChanDat[con.ChanCur].stat:=5;
          end;
        5:exit;
        else begin;
          pipeLineClose(con.ChanDat[con.ChanCur].pipe);
          add2packetBegin(pck1,97);
          add2packetInteger(pck1,con.ChanDat[con.ChanCur].remID);
          sendPacket(con,pck1);
          move(con.ChanDat[con.ChanNum],con.ChanDat[con.ChanCur],sizeof(con.ChanDat[con.ChanCur]));
          fillchar(con.ChanDat[con.ChanNum],sizeof(con.ChanDat[con.ChanNum]),0);
          dec(con.ChanNum);
          exit;
          end;
        end;
      exit;
      end;
    q:=1;
    case pck1.d[1] of
      98:begin; {channel request}
        p:=FindOneLocalConnectID(con,get4packetInteger(q,pck1));
        if (p<1) then exit;
        a:=get4packetString(q,pck1);
        i:=get4packetBoolean(q,pck1);
        if (pos('|'+a+'|',safeRequestList)=0) then goto f5;
        if (i=0) then exit;
        add2packetBegin(pck1,99);
        add2packetInteger(pck1,con.ChanDat[p].remID);
        sendPacket(con,pck1);
        exit;
        end;
      99:begin; {request success}
        p:=FindOneLocalConnectID(con,get4packetInteger(q,pck1));
        if (p<1) then exit;
        if (con.ChanDat[p].stat<>5) then exit;
        informClient(p,'connect');
        con.ChanDat[p].stat:=1;
        exit;
        end;
      100:begin; {request failure}
        p:=FindOneLocalConnectID(con,get4packetInteger(q,pck1));
        if (p<1) then exit;
        if (con.ChanDat[p].stat<>5) then exit;
        informClient(p,'error:channel opened, request failed');
        con.ChanDat[p].stat:=0;
        exit;
        end;
      91:begin; {open confirmation}
        p:=FindOneLocalConnectID(con,get4packetInteger(q,pck1));
        if (p<1) then exit;
        if (con.ChanDat[p].stat<>3) then exit;
        con.ChanDat[p].remID:=get4packetInteger(q,pck1);
        i:=get4packetInteger(q,pck1);
        if (i<1) or (i>RemoteWindowSize) then i:=RemoteWindowSize;
        con.ChanDat[p].Window:=i;
        i:=get4packetInteger(q,pck1);
        if (i<1) or (i>$200) then i:=$200;
        con.ChanDat[p].MaxPck:=i;
        informClient(p,'opened');
        con.ChanDat[p].stat:=4;
        exit;
        end;
      92:begin; {open failure}
        p:=FindOneLocalConnectID(con,get4packetInteger(q,pck1));
        if (p<1) then exit;
        if (con.ChanDat[p].stat<>3) then exit;
        get4packetInteger(q,pck1);
        a:=get4packetString(q,pck1);
        get4packetString(q,pck1);
        informClient(p,'error:open refused: '+a);
        con.ChanDat[p].stat:=0;
        exit;
        end;
      else processAnyPacket(con,pck1);
      end;
    exit;
    end;
  9:begin; {authenticate wait}
    if (GetTimePast(con.time)<3) then exit;
    move(con.planNum1[1],i,sizeof(i));
    if (i>0) then begin; con.stat:=8;goto f4; end;
    if (GetTimePast(con.time)<13) then exit;
    sendDisconnectPacket(con,14,'authentication failed!');
    exit;
    end;
  8:begin; {authenticate request}
    if receivePacket(con,pck1) then exit;
    q:=1;
    if (pck1.d[1]=5) then begin;
      a:=get4packetString(q,pck1);
      if (a<>serviceNameAuth) then begin;
        sendDisconnectPacket(con,7,'service not available: '+a);
        exit;
        end;
      add2packetBegin(pck1,6);
      add2packetString(pck1,serviceNameAuth);
      sendPacket(con,pck1);
      exit;
      end;
    if (pck1.d[1]=61) then begin;
      move(con.planNum1[5],i,sizeof(i));
      move(con.planNum1[9],c,sizeof(c));
      if (i<>1) then exit;
      if (get4packetInteger(q,pck1)<>1) then exit;
      b:=get4packetString(q,pck1);
      goto f3;
      end;
    if (pck1.d[1]<>50) then begin;
      processAnyPacket(con,pck1);
      exit;
      end;
    i:=0;
    move(i,con.planNum1[5],sizeof(i));
    c:=get4packetString(q,pck1);
    a:=get4packetString(q,pck1);
    if (a<>serviceNameConn) then begin;
      sendDisconnectPacket(con,7,'service not available: '+a);
      exit;
      end;
    a:=get4packetString(q,pck1);
    if (a=authentNothing) then goto f4;
    if (a=authentPassword) then begin;
      get4packetBoolean(q,pck1);
      b:=get4packetString(q,pck1);
      goto f3;
      end;
    if (a=authentKeyboard) then begin;
      get4packetString(q,pck1);
      a:=get4packetString(q,pck1);
      i:=1;
      move(i,con.planNum1[5],sizeof(i));
      move(c,con.planNum1[9],sizeof(c));
      add2packetBegin(pck1,60);
      add2packetString(pck1,'password authentication');
      add2packetString(pck1,'');
      add2packetString(pck1,'');
      add2packetInteger(pck1,1);
      add2packetString(pck1,'password:');
      add2packetBoolean(pck1,false);
      sendPacket(con,pck1);
      exit;
      end;
    f4:
    add2packetBegin(pck1,51);
    add2packetString(pck1,authentPassword+','+authentKeyboard);
    add2packetBoolean(pck1,false);
    sendPacket(con,pck1);
    exit;
    f3:
    if (authenticateOneUser(c,b,'ssh with '+ipAddr2string(con.adr)+' '+BStr(con.prt),LoginFlags_accessSsh,i)<>0) then begin;
      WriteLn('authentication failed with '+ipAddr2string(con.adr)+' '+BStr(con.prt)+' '+c);
      move(con.planNum1[1],i,sizeof(i));
      dec(i);
      move(i,con.planNum1[1],sizeof(i));
      con.stat:=9;
      con.time:=CurrentTime;
      exit;
      end;
    con.userid:=i;
    con.authed:=true;
    con.stat:=77;
    add2packetBegin(pck1,52);
    sendPacket(con,pck1);
    exit;
    end;
  7:begin; {apply new keys}
    if receivePacket(con,pck1) then exit;
    if (pck1.d[1]<>21) then begin;
      processAnyPacket(con,pck1);
      exit;
      end;
    add2packetBegin(pck1,21);
    sendPacket(con,pck1);
    move(con.planNum1,pck1,sizeof(pck1));
    move(con.sessID,b[1],sizeof(con.sessID));
    b[0]:=chr(sizeof(con.sessID));
    p:=con.planEncRL;
    a:=copy(GenerateEncryptKeys(pck1,'C'+b),1,CipherAlgoList[p].ks);
    c:=GenerateEncryptKeys(pck1,'A'+b);
    CryptoBegCipher(con.encRLc,CipherAlgoList[p].a,a,c);
    con.encRLs:=CipherAlgoList[p].s;
    p:=con.planEncLR;
    a:=copy(GenerateEncryptKeys(pck1,'D'+b),1,CipherAlgoList[p].ks);
    c:=GenerateEncryptKeys(pck1,'B'+b);
    CryptoBegCipher(con.encLRc,CipherAlgoList[p].a,a,c);
    con.encLRs:=CipherAlgoList[p].s;
    p:=con.planMacRL;
    a:=GenerateEncryptKeys(pck1,'E'+b);
    HasherInitialize(con.macRLa,con.macRLb,p,a);
    con.macRLs:=HasherAlgoList[p].s;
    p:=con.planMacLR;
    a:=GenerateEncryptKeys(pck1,'F'+b);
    HasherInitialize(con.macLRa,con.macLRb,p,a);
    con.macLRs:=HasherAlgoList[p].s;
    con.secure:=true;
    con.ChanCur:=1;
    if con.authed then begin;
      con.stat:=77;
      exit;
      end;
    i:=5;move(i,con.planNum1[1],sizeof(i));
    i:=0;move(i,con.planNum1[5],sizeof(i));
    con.stat:=8;
    end;
  6:begin; {key exchange init}
    if receivePacket(con,pck1) then exit;
    if (pck1.d[1]<>30) then begin;
      processAnyPacket(con,pck1);
      exit;
      end;
    i:=con.ChanCur;con.ChanCur:=0;if (i<>0) then exit;
    if ReadDiffieHellmanGroup(con.planGroup,grp) then goto f1;
    i:=BigNumSizeInBits(grp.p);
    o:=i-2;
    i:=i div diffieHellmanDiv;
    if (i<diffieHellmanMin) then i:=diffieHellmanMin;
    if (i>diffieHellmanMax) then i:=diffieHellmanMax;
    if (i>o) then i:=o;
    GetRndBigNum(con.planNum1,i);
    q:=1;
    get4packetBignum(q,pck1,num1);
    BigNumPowerMod(grp.g,con.planNum1,grp.p,num2);
    BigNumPowerMod(num1,con.planNum1,grp.p,num3);
    pck1.s:=0;add2packetBignum(pck1,num1);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck1.s:=0;add2packetBignum(pck1,num2);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck1.s:=0;add2packetBignum(pck1,num3);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck2.s:=0;
    case con.planSig of
      1:GetCurrentDSSkey(pck2);
      2:GetCurrentRSAkey(pck2);
      else goto f1;
      end;
    add2packetBegin(pck1,31);
    add2packetBinHdr(pck1,pck2.d,pck2.s);
    add2packetBignum(pck1,num2);
    CryptoFinHasher(con.planHsh,num1,p);
    if not con.secure then move(num1,con.sessID,sizeof(con.sessID));
    pck2.s:=0;
    add2packetBignum(pck2,num3);
    add2packetBinary(pck2,num1,p);
    move(pck2,con.planNum1,sizeof(con.planNum1));
    pck2.s:=0;
    case con.planSig of
      1:SignDataWithDSSkey(pck2,num1,p);
      2:SignDataWithRSAkey(pck2,num1,p);
      else goto f1;
      end;
    add2packetBinHdr(pck1,pck2.d,pck2.s);
    sendPacket(con,pck1);
    con.stat:=7;
    end;
  5:begin; {group exchange init}
    if receivePacket(con,pck1) then exit;
    if (pck1.d[1]<>32) then begin;
      processAnyPacket(con,pck1);
      exit;
      end;
    if ReadDiffieHellmanGroup(con.planGroup,grp) then goto f1;
    q:=1;
    get4packetBignum(q,pck1,num1);
    BigNumPowerMod(grp.g,con.planNum1,grp.p,num2);
    BigNumPowerMod(num1,con.planNum1,grp.p,num3);
    pck1.s:=0;add2packetBignum(pck1,num1);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck1.s:=0;add2packetBignum(pck1,num2);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck1.s:=0;add2packetBignum(pck1,num3);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck2.s:=0;
    case con.planSig of
      1:GetCurrentDSSkey(pck2);
      2:GetCurrentRSAkey(pck2);
      else goto f1;
      end;
    add2packetBegin(pck1,33);
    add2packetBinHdr(pck1,pck2.d,pck2.s);
    add2packetBignum(pck1,num2);
    CryptoFinHasher(con.planHsh,num1,p);
    if not con.secure then move(num1,con.sessID,sizeof(con.sessID));
    pck2.s:=0;
    add2packetBignum(pck2,num3);
    add2packetBinary(pck2,num1,p);
    move(pck2,con.planNum1,sizeof(con.planNum1));
    pck2.s:=0;
    case con.planSig of
      1:SignDataWithDSSkey(pck2,num1,p);
      2:SignDataWithRSAkey(pck2,num1,p);
      else goto f1;
      end;
    add2packetBinHdr(pck1,pck2.d,pck2.s);
    sendPacket(con,pck1);
    con.stat:=7;
    end;
  4:begin; {group exchange request}
    if receivePacket(con,pck1) then exit;
    if (pck1.d[1]=30) then begin;
      i:=con.ChanCur;con.ChanCur:=0;if (i<>0) then exit;
      q:=1;
      o:=get4packetInteger(q,pck1);
      pck1.s:=0;
      add2packetInteger(pck1,o);
      goto f2;
      end;
    if (pck1.d[1]<>34) then begin;
      processAnyPacket(con,pck1);
      exit;
      end;
    i:=con.ChanCur;con.ChanCur:=0;if (i<>0) then exit;
    q:=1;
    i:=get4packetInteger(q,pck1);
    o:=get4packetInteger(q,pck1);
    p:=get4packetInteger(q,pck1);
    pck1.s:=0;
    add2packetInteger(pck1,i);
    add2packetInteger(pck1,o);
    add2packetInteger(pck1,p);
    f2:
    con.planGroup:=FindDiffieHellmanGroup(o);
    if ReadDiffieHellmanGroup(con.planGroup,grp) then goto f1;
    add2packetBignum(pck1,grp.p);
    add2packetBignum(pck1,grp.g);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    i:=BigNumSizeInBits(grp.p);
    o:=i-2;
    i:=i div diffieHellmanDiv;
    if (i<diffieHellmanMin) then i:=diffieHellmanMin;
    if (i>diffieHellmanMax) then i:=diffieHellmanMax;
    if (i>o) then i:=o;
    GetRndBigNum(con.planNum1,i);
    add2packetBegin(pck1,31);
    add2packetBignum(pck1,grp.p);
    add2packetBignum(pck1,grp.g);
    sendPacket(con,pck1);
    con.stat:=5;
    end;
  3:begin; {key exchange init}
    if receivePacket(con,pck1) then exit;
    if (pck1.d[1]<>20) then begin;
      processAnyPacket(con,pck1);
      exit;
      end;
    if readKeyExchangeInit(con,pck1,true) then exit;
    CryptoBegHasher(con.planHsh,sha1algoNum,'','');
    pck2.s:=0;
    add2packetString(pck2,con.remoteSW);
    add2packetString(pck2,GetServerVersionString);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    pck2.s:=0;add2packetBinHdr(pck2,pck1.d,pck1.s);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    makeKeyExchangeInit(con,pck1);
    pck2.s:=0;add2packetBinHdr(pck2,pck1.d,pck1.s);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    pck1.s:=0;
    case con.planSig of
      1:GetCurrentDSSkey(pck1);
      2:GetCurrentRSAkey(pck1);
      else goto f1;
      end;
    pck2.s:=0;add2packetBinHdr(pck2,pck1.d,pck1.s);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    end;
  2:begin; {client software}
    i:=1;
    if (pipeLineRecv(con.pipe,bb,i)<>0) then i:=0;
    if (i<1) then begin;
      pipeLineStats(con.pipe,i,o,o);
      if (i<>0) then exit;
      con.stat:=0;
      con.err:='connection lost';
      exit;
      end;
    con.time:=CurrentTime;
    if (bb=13) then exit;
    if (bb<>10) then begin;
      con.remoteSW:=con.remoteSW+chr(bb);
      exit;
      end;
    if (copy(con.remoteSW,1,4)<>'SSH-') then begin; con.remoteSW:='';exit; end;
    con.macLRs:=0;
    con.macRLs:=0;
    con.encLRs:=8;
    con.encRLs:=8;
    makeKeyExchangeInit(con,pck1);
    sendPacket(con,pck1);
    con.stat:=3;
    end;
  1:begin; {init}
    if TCPlookConnected(con.pipe,con.adr,con.prt,i) then begin;
      doConn:=(con.pipe=0);
      exit;
      end;
    WriteLn('connection accepted from '+ipAddr2string(con.adr)+' '+BStr(con.prt)+' to '+BStr(i));
    for i:=1 to ConnectionNum do begin;
      if (i=conN) then continue;
      if ConnectionDat^[i].secure then continue;
      if (ConnectionDat^[i].stat>=100) then continue;
      if TCPcompareAddress(ConnectionDat^[i].adr,con.adr) then begin;
        con.stat:=0;
        con.err:='duplicated connection';
        exit;
        end;
      end;
    a:=GetServerVersionString+#10;
    pipeLineSend(con.pipe,a[1],length(a));
    for i:=1 to 8 do con.cokieL[i]:=random($10000);
    con.stat:=2;
    end;
  99:begin; {tcp emulation}
    pipeLineStats(con.pipe,i,o,p);
    if (o<sizeof(tcpDat2)) then exit;
    i:=sizeof(tcpDat2);
    if (pipeLineRecv(con.pipe,tcpDat2,i)<>0) then exit;
    if (tcpDat2.cmd=2) then begin;
      BugOS_ProcessName(con.proc,pck1,i,i,o);
      if (o and $40=0) then begin; con.stat:=0;exit; end;
      for i:=1 to ListenerNum do begin;
        if (ListenerDat[i].pipe<>0) then continue;
        if (ListenerDat[i].port<>tcpDat2.prt) then continue;
        ListenerDat[i].pipe:=con.pipe;
        ListenerDat[i].proc:=con.proc;
        move(tcpDat2.adr,ListenerDat[i].wind,sizeof(ListenerDat[i].wind));
        fillchar(tcpDat2,sizeof(tcpDat2),0);
        tcpDat2.cmd:=3;
        move(serverAddr,tcpDat2.adr,sizeof(tcpDat2.adr));
        tcpDat2.prt:=ListenerDat[i].port;
        tcpDat2.dat:=serverPort;
        pipeLineSend(con.pipe,tcpDat2,sizeof(tcpDat2));
        con.pipe:=0;
        con.proc:=0;
        con.stat:=0;
        exit;
        end;
      con.stat:=0;
      exit;
      end;
    if (tcpDat2.cmd<>1) then begin; con.stat:=0;exit; end;
    p:=-1;
    for i:=1 to ListenerNum do if (ListenerDat[i].port=tcpDat2.prt) then p:=i;
    if (p<1) then begin; con.stat:=0;exit; end;
    for i:=1 to ConnectionNum do begin;
      if (i=conN) then continue;
      if (ConnectionDat^[i].stat<100) then continue;
      if (con.proc<>ConnectionDat^[i].proc) then continue;
      if not TCPcompareAddress(tcpDat2.adr,ConnectionDat^[i].adr) then continue;
      if (ConnectionDat^[i].ChanNum>=ChannelMaximum) then begin; con.stat:=0;exit; end;
      inc(ConnectionDat^[i].ChanNum);
      o:=ConnectionDat^[i].ChanNum;
      ConnectionDat^[i].ChanDat[o].pipe:=con.pipe;
      ConnectionDat^[i].ChanDat[o].port:=p;
      ConnectionDat^[i].ChanDat[o].stat:=2;
      ConnectionDat^[i].ChanDat[o].locID:=GenerateLocalConnectID(ConnectionDat^[i]);
      fillchar(tcpDat2,sizeof(tcpDat2),0);
      tcpDat2.cmd:=3;
      move(serverAddr,tcpDat2.adr,sizeof(tcpDat2.adr));
      tcpDat2.prt:=serverPort;
      tcpDat2.dat:=0;
      pipeLineSend(con.pipe,tcpDat2,sizeof(tcpDat2));
      con.pipe:=0;
      con.proc:=0;
      con.stat:=0;
      exit;
      end;
    con.ChanNum:=1;
    con.ChanDat[1].pipe:=con.pipe;
    con.ChanDat[1].port:=p;
    con.ChanDat[1].stat:=2;
    con.ChanDat[1].locID:=GenerateLocalConnectID(con);
    con.pipe:=0;
    con.stat:=100;
    move(tcpDat2.adr,con.adr,sizeof(con.adr));
    TCPbeginConnect(con.pipe,65536,con.adr,serverPort);
    exit;
    end;
  100:begin; {tcp connecting to remote}
    if TCPlookConnected(con.pipe,a,i,o) then begin;
      if (con.pipe<>0) then exit;
      con.stat:=0;
      exit;
      end;
    con.prt:=i;
    fillchar(tcpDat2,sizeof(tcpDat2),0);
    tcpDat2.cmd:=3;
    move(serverAddr,tcpDat2.adr,sizeof(tcpDat2.adr));
    tcpDat2.prt:=serverPort;
    tcpDat2.dat:=0;
    pipeLineSend(con.ChanDat[1].pipe,tcpDat2,sizeof(tcpDat2));
    a:=GetServerVersionString+#10;
    pipeLineSend(con.pipe,a[1],length(a));
    for i:=1 to 8 do con.cokieL[i]:=random($10000);
    con.stat:=101;
    informClient(1,'locTCP:'+ipAddr2string(serverAddr)+' '+BStr(con.prt));
    informClient(1,'remTCP:'+ipAddr2string(con.adr)+' '+BStr(serverPort));
    end;
  101:begin; {version string}
    i:=1;
    if (pipeLineRecv(con.pipe,bb,i)<>0) then i:=0;
    if (i<1) then begin;
      pipeLineStats(con.pipe,i,o,o);
      if (i<>0) then exit;
      informClient(1,'error:connection lost');
      con.stat:=0;
      exit;
      end;
    con.time:=CurrentTime;
    if (bb=13) then exit;
    if (bb<>10) then begin;
      con.remoteSW:=con.remoteSW+chr(bb);
      exit;
      end;
    if (copy(con.remoteSW,1,4)<>'SSH-') then begin; con.remoteSW:='';exit; end;
    con.macLRs:=0;
    con.macRLs:=0;
    con.encLRs:=8;
    con.encRLs:=8;
    informClient(1,'locSSH:'+GetServerVersionString);
    informClient(1,'remSSH:'+con.remoteSW);
    makeKeyExchangeInit(con,pck1);
    sendPacket(con,pck1);
    con.stat:=102;
    end;
  102:begin; {key exchange init}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]<>20) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    if readKeyExchangeInit(con,pck1,false) then begin; sendErr2clnt;exit; end;
    CryptoBegHasher(con.planHsh,sha1algoNum,'','');
    pck2.s:=0;
    add2packetString(pck2,GetServerVersionString);
    add2packetString(pck2,con.remoteSW);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    makeKeyExchangeInit(con,pck3);
    pck2.s:=0;add2packetBinHdr(pck2,pck3.d,pck3.s);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    pck2.s:=0;add2packetBinHdr(pck2,pck1.d,pck1.s);
    CryptoAddHasher(con.planHsh,pck2.d,pck2.s);
    informClient(1,'plan.kex:'+GetKeyXchgAlgName(con.planKex));
    informClient(1,'plan.sign:'+GetHostKeyAlgName(con.planSig));
    informClient(1,'plan.l2r:'+CipherAlgoList[con.planEncLR].n+' '+HasherAlgoList[con.planMacLR].n);
    informClient(1,'plan.r2l:'+CipherAlgoList[con.planEncRL].n+' '+HasherAlgoList[con.planMacRL].n);
    end;
  103:begin; {group exchange request}
    add2packetBegin(pck1,34);
    add2packetInteger(pck1,diffieHellmanDiv*diffieHellmanMin);
    add2packetInteger(pck1,((diffieHellmanMin+diffieHellmanMax)*diffieHellmanDiv) shr 1);
    add2packetInteger(pck1,diffieHellmanDiv*diffieHellmanMax);
    sendPacket(con,pck1);
    con.stat:=104;
    end;
  104:begin; {group exchange group}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]<>31) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    q:=1;
    get4packetBignum(q,pck1,grp.p);
    get4packetBignum(q,pck1,grp.g);
    move(grp,con.planGrp,sizeof(con.planGrp));
    i:=BigNumSizeInBits(grp.p);
    o:=i-2;
    i:=i div diffieHellmanDiv;
    if (i<diffieHellmanMin) then i:=diffieHellmanMin;
    if (i>diffieHellmanMax) then i:=diffieHellmanMax;
    if (i>o) then i:=o;
    GetRndBigNum(con.planNum1,i);
    BigNumPowerMod(grp.g,con.planNum1,grp.p,con.planNum2);
    add2packetBegin(pck1,32);
    add2packetBignum(pck1,con.planNum2);
    sendPacket(con,pck1);
    con.stat:=105;
    end;
  105:begin; {group exchange reply}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]<>33) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    goto f6;
    end;
  106:begin; {key exchange init}
    if ReadDiffieHellmanGroup(con.planGroup,grp) then goto f1;
    move(grp,con.planGrp,sizeof(con.planGrp));
    i:=BigNumSizeInBits(grp.p);
    o:=i-2;
    i:=i div diffieHellmanDiv;
    if (i<diffieHellmanMin) then i:=diffieHellmanMin;
    if (i>diffieHellmanMax) then i:=diffieHellmanMax;
    if (i>o) then i:=o;
    GetRndBigNum(con.planNum1,i);
    BigNumPowerMod(grp.g,con.planNum1,grp.p,con.planNum2);
    add2packetBegin(pck1,30);
    add2packetBignum(pck1,con.planNum2);
    sendPacket(con,pck1);
    con.stat:=107;
    end;
  107:begin; {key exchange reply}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]<>31) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    f6:
    move(con.planGrp,grp,sizeof(grp));
    q:=1;
    get4packetBinHdr(q,pck1,pck3.d,pck3.s);
    get4packetBignum(q,pck1,num1);
    get4packetBinHdr(q,pck1,pck2.d,pck2.s);
    pck1.s:=0;add2packetBinHdr(pck1,pck3.d,pck3.s);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    case con.planKex of
      1:begin;
        pck1.s:=0;
        add2packetInteger(pck1,diffieHellmanDiv*diffieHellmanMin);
        add2packetInteger(pck1,((diffieHellmanMin+diffieHellmanMax)*diffieHellmanDiv) shr 1);
        add2packetInteger(pck1,diffieHellmanDiv*diffieHellmanMax);
        CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
        pck1.s:=0;add2packetBignum(pck1,grp.p);
        CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
        pck1.s:=0;add2packetBignum(pck1,grp.g);
        CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
        end;
      2:begin;
        end;
      else goto f1;
      end;
    informClient(1,'diffie:'+BigNumGenStat(grp.g)+' '+BigNumGenStat(grp.p)+' '+BigNumGenStat(con.planNum1));
    BigNumPowerMod(num1,con.planNum1,grp.p,num2);
    pck1.s:=0;add2packetBignum(pck1,con.planNum2);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck1.s:=0;add2packetBignum(pck1,num1);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    pck1.s:=0;add2packetBignum(pck1,num2);
    CryptoAddHasher(con.planHsh,pck1.d,pck1.s);
    CryptoFinHasher(con.planHsh,pck1.d,pck1.s);
    if not con.secure then move(pck1.d,con.sessID,sizeof(con.sessID));
    pck4.s:=0;
    add2packetBignum(pck4,num2);
    add2packetBinary(pck4,pck1.d,pck1.s);
    move(pck4,con.planNum1,sizeof(con.planNum1));
    case con.planSig of
      1:a:=VerifySignWithDSS(pck3,pck2,pck1.d,pck1.s);
      2:a:=VerifySignWithRSA(pck3,pck2,pck1.d,pck1.s);
      else goto f1;
      end;
    if (a='') then begin;
      informClient(1,'error:host signature error');
      con.stat:=0;
      exit;
      end;
    CryptoImmHasher(md5algoNum,'','',pck3.d,pck3.s);
    b:='';
    for i:=1 to pck3.s do b:=b+':'+byte2hextype(pck3.d[i]);
    a:=a+' '+copy(b,2,255);
    informClient(1,'hostkey:'+a);
    add2packetBegin(pck1,21);
    sendPacket(con,pck1);
    con.stat:=108;
    end;
  108:begin; {apply keys}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]<>21) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    move(con.planNum1,pck1,sizeof(pck1));
    move(con.sessID,b[1],sizeof(con.sessID));
    b[0]:=chr(sizeof(con.sessID));
    p:=con.planEncLR;
    a:=copy(GenerateEncryptKeys(pck1,'C'+b),1,CipherAlgoList[p].ks);
    c:=GenerateEncryptKeys(pck1,'A'+b);
    CryptoBegCipher(con.encLRc,CipherAlgoList[p].a,a,c);
    con.encLRs:=CipherAlgoList[p].s;
    p:=con.planEncRL;
    a:=copy(GenerateEncryptKeys(pck1,'D'+b),1,CipherAlgoList[p].ks);
    c:=GenerateEncryptKeys(pck1,'B'+b);
    CryptoBegCipher(con.encRLc,CipherAlgoList[p].a,a,c);
    con.encRLs:=CipherAlgoList[p].s;
    p:=con.planMacLR;
    a:=GenerateEncryptKeys(pck1,'E'+b);
    HasherInitialize(con.macLRa,con.macLRb,p,a);
    con.macLRs:=HasherAlgoList[p].s;
    p:=con.planMacRL;
    a:=GenerateEncryptKeys(pck1,'F'+b);
    HasherInitialize(con.macRLa,con.macRLb,p,a);
    con.macRLs:=HasherAlgoList[p].s;
    con.secure:=true;
    con.ChanCur:=1;
    if con.authed then begin;
      con.stat:=777;
      exit;
      end;
    informClient(1,'secure');
    add2packetBegin(pck1,5);
    add2packetString(pck1,serviceNameAuth);
    sendPacket(con,pck1);
    con.stat:=109;
    end;
  109:begin; {service accept}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]<>6) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    informClient(1,'username?');
    a:='';
    move(a,con.planNum1,sizeof(a));
    con.stat:=110;
    end;
  110:begin; {username}
    if not receivePacket(con,pck1) then processAnyPacket(con,pck1);
    sendErr2clnt;
    move(con.planNum1,c,sizeof(c));
    i:=ReadUserStr(c);
    move(c,con.planNum1,sizeof(c));
    if (i<>0) then exit;
    informClient(1,'password?');
    a:='';
    move(a,con.planNum2,sizeof(a));
    con.stat:=111;
    end;
  111:begin; {password}
    if not receivePacket(con,pck1) then processAnyPacket(con,pck1);
    sendErr2clnt;
    move(con.planNum2,c,sizeof(c));
    i:=ReadUserStr(c);
    move(c,con.planNum2,sizeof(c));
    if (i<>0) then exit;
    add2packetBegin(pck1,50);
    move(con.planNum1,c,sizeof(c));
    add2packetString(pck1,c);
    add2packetString(pck1,serviceNameConn);
    add2packetString(pck1,authentPassword);
    add2packetBoolean(pck1,False);
    move(con.planNum2,c,sizeof(c));
    add2packetString(pck1,c);
    sendPacket(con,pck1);
    con.stat:=112;
    end;
  112:begin; {authenticate}
    if receivePacket(con,pck1) then begin; sendErr2clnt;exit; end;
    if (pck1.d[1]=51) then begin;
      informClient(1,'password?');
      a:='';
      move(a,con.planNum2,sizeof(a));
      con.stat:=111;
      exit;
      end;
    if (pck1.d[1]=53) then exit;
    if (pck1.d[1]<>52) then begin;
      processAnyPacket(con,pck1);
      sendErr2clnt;
      exit;
      end;
    informClient(1,'accepted');
    con.authed:=true;
    con.userid:=GuestUserIDmasking;
    con.stat:=777;
    end;
  0:begin; doConn:=True;exit; end; {disconnect}
  else begin; f1:con.err:='bug';doConn:=True;exit; end;
  end;
End;
