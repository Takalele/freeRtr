char pipeline should opened for this process...
after it, the process acts as tcp process...
exceptions are the following:

of course, udp not support...

when new incoming pipeline is estabilished, the
tcp.connected packet will postfixed with a dword,
the user id of the authenticated user...
(the start listening procedure is identical)

when client tries to connect, it sends a tcp.connect
message. it's port field will be used to identify
the requested service... after it, the tcp.connected
message will be sent to the client when tcp has
estabilished the connection... at this point, the
ssh must negotiate things... this process will send
information to the client indicating the current
status of connection... each line will be terminated
with a cr+lf pair...
information will be the following:

- error:<error message>
- locTCP:<local ip address> <local port number>
- remTCP:<remote ip address> <remote port number>
- locSSH:<local ssh software name>
- remSSH:<remote ssh software name>
- plan.l2r:<local-->remote cipher> <local-->remote hash>
- plan.r2l:<remote-->local cipher> <remote-->local hash>
- plan.kex:<kex exchange method>
- plan.sign:<signature method>
- diffie:<used/total generator> <used/total prime> <used/total random>
- hostkey:<type> <size> <signature>
- secure
  after it, the connection is secure...
- username?
  client responds with the user name and a cr pair...
- password?
  client responds with the password and a cr pair...
- accepted
- opening
- opened
- requesting:<subsystem name>
- connect
  after it, the connection is estabilished...
