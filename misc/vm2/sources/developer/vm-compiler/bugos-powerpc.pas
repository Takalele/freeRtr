{$stack 1k}
{$heap 16k}
{$sysinc system.inc}
{$sysinc param.inc}
{$sysinc alap.inc}
{$sysinc filesys.inc}
{$sysinc filesys2.inc}
{$sysinc textfile.inc}
Const
  regNames:array[1..6] of string[3]=('r20','r21','r22','r23','r24','r25');
  CompareSeenSign:Boolean=true;
Var tout,tinp,ttbl:xtText;


Procedure outputLine(a,b:String);
Begin;
if (b<>'') then begin;
  while (length(a)<30) do a:=a+' ';
  a:=a+' ;'+b;
  end;
xtWriteLn(tout,a);
End;

Function getBaseName:String;
Var
  i,o:Word;
  a:String;
Begin;
a:=ParamStr(3);
if (a<>'') then begin; getBaseName:=a;exit; end;
a:=ParamStr(0);
o:=0;
for i:=1 to length(a) do if (a[i]='\') then o:=i;
a:=copy(a,o+1,666);
o:=666;
for i:=1 to length(a) do if (a[i]='.') then o:=i;
a:='c:\sources\developer\vm-compiler\'+copy(a,1,o-1)+'.table';
getBaseName:=a;
End;

Function getWord(var a:String):String;
Var i:Word;
Begin;
i:=pos(' ',a);
if (i<1) then i:=$666;
getWord:=copy(a,1,i-1);
a:=copy(a,i+1,$666);
End;

function getSizes(var a:string):integer;
var i:integer;
begin;
a[length(a)+1]:=#255;
case a[1] of
  'b':i:=1;
  'w':i:=2;
  'd':i:=3;
  'q':i:=4;
  else i:=-1;
  end;
delete(a,1,1);
getSizes:=i;
end;

function getSigns(var a:string):integer;
var i:integer;
begin;
a[length(a)+1]:=#255;
case a[1] of
  's':i:=1;
  'u':i:=2;
  else i:=-1;
  end;
delete(a,1,1);
getSigns:=i;
end;

function getFormats(var a:string):integer;
var i:integer;
begin;
a[length(a)+1]:=#255;
case a[1] of
  'd':i:=1;
  'm':i:=2;
  'l':i:=3;
  else i:=-1;
  end;
delete(a,1,1);
getFormats:=i;
end;

function getRegister(a:string;dat,ptr:boolean):integer;
var i:integer;
begin;
i:=-1;
if dat then begin;
  if (a='a') then i:=1;
  if (a='b') then i:=2;
  if (a='c') then i:=3;
  if (a='d') then i:=4;
  end;
if ptr then begin;
  if (a='src') then i:=5;
  if (a='trg') then i:=6;
  end;
getRegister:=i;
end;

function getCondition(a:string):integer;
var i:integer;
begin;
i:=-1;
if (a='nbe') then a:='a';
if (a='nae') then a:='b';
if (a='nb') then a:='ae';
if (a='na') then a:='be';
if (a='a') then i:=1;
if (a='b') then i:=2;
if (a='ne') then i:=3;
if (a='e') then i:=4;
if (a='ae') then i:=5;
if (a='be') then i:=6;
getCondition:=i;
end;




Function CompileOneLine(c:String;lineNum:LongInt):Boolean;
Label oke,vege;
Var
  siz1,siz2,siz3:integer;
  sig1,sig2,sig3:integer;
  reg1,reg2,reg3:integer;
  par1,par2:String;
  oc,a,b,d:String;
  i,o,p:LongInt;

Function getLabelName:String;
Begin;
getLabelName:='autolabel'+BStr(lineNum)+'_';
End;

Procedure CodeOneNum(r,n:String);
Var i:LongInt;
Begin;
i:=BVal(n);
if (i<>0) or (n='0') then begin;
  if (i shr 16=0) then n:='r0' else begin;
    outputLine('lis '+r+','+BStr(i shr 16),'');
    n:=r;
    end;
  outputLine('ori '+r+','+n+','+BStr(i and $ffff),'');
  exit;
  end;
outputLine('lis '+r+','+n,'');
outputLine('ori '+r+','+r+','+n,'');
End;

Procedure CodeOnePush(r:String);
Begin;
outputLine('addi r31,r31,-4','');
outputLine('stw '+r+',0(r31)','push '+r);
End;

Procedure CodeOnePop(r:String);
Begin;
outputLine('lwz '+r+',0(r31)','pop '+r);
outputLine('addi r31,r31,4','');
End;

Function CodeOneMem(a:string):Boolean;
Var o:longint;
Begin;
CodeOneMem:=true;
if (copy(a,1,1)<>'[') then exit;
if (copy(a,length(a),1)<>']') then exit;
a:=copy(a,2,length(a)-2);
if (length(a)=3) then a:=a+'+0';
o:=getRegister(copy(a,1,3),false,true);
if (o<1) then exit;
a:=copy(a,4,$666);
if (a='+0') or (a='-0') then a:='0';
CodeOneNum('r10',a);
outputLine('add r10,r10,'+regNames[o],'');
CodeOneMem:=false;
End;

Procedure codeOneLSBconvert(siz:LongInt;trg,src:String);
Begin;
case siz of
  1:begin;
    if (src=trg) then exit;
    outputLine('andi. '+trg+','+src+',0ffh','');
    end;
  2:begin;
    outputLine('slwi r10,'+src+',8','');
    outputLine('srwi r11,'+src+',8','');
    outputLine('andi. r11,r11,0ffh','');
    outputLine('andi. r10,r10,0ff00h','');
    outputLine('xor '+trg+',r11,r10','');
    end;
  3:begin;
    outputLine('slwi r11,'+src+',24','');
    outputLine('srwi r10,'+src+',24','');
    outputLine('xor r11,r11,r10','');
    outputLine('andi. r10,'+src+',0ff00h','');
    outputLine('slwi r10,r10,8','');
    outputLine('xor r11,r11,r10','');
    outputLine('srwi r10,'+src+',8','');
    outputLine('andi. r10,r10,0ff00h','');
    outputLine('xor '+trg+',r11,r10','');
    end;
  end;
End;

Function codeOneRead(c:String):Boolean;
Var i:LongInt;
Begin;
codeOneRead:=true;
a:=getWord(c);
reg3:=getFormats(a);
if (reg3<0) then exit;
sig1:=getSigns(a);
if (sig1<0) then exit;
siz1:=getSizes(a);
if (siz1<0) then exit;
sig2:=getSigns(a);
if (sig2<0) then exit;
siz2:=getSizes(a);
if (siz2<0) then exit;
par1:=getWord(c);
par2:=getWord(c);
if (siz2>siz1) then siz2:=siz1;
reg1:=getRegister(par1,true,true);
if (reg1<0) then exit;
b:=regNames[reg1];
if CodeOneMem(par2) then exit;
if (siz1>siz2) and ((sig1<>1) or (sig2<>1)) then outputLine('or '+b+',r0,r0','');
case siz2 of
  1:outputLine('lbz '+b+',0(r10)','');
  2:outputLine('lhz '+b+',0(r10)','');
  3:outputLine('lwz '+b+',0(r10)','');
  else exit;
  end;
if (reg3=3) then codeOneLSBconvert(siz2,b,b);
if (siz1>siz2) and (sig1=1) and (sig2=1) then case siz2 of
  1:outputLine('extsb '+b+','+b,'');
  2:outputLine('extsh '+b+','+b,'');
  else exit;
  end;
codeOneRead:=false;
End;

Function codeOneWrite(c:String):Boolean;
Var i:LongInt;
Begin;
codeOneWrite:=True;
a:=getWord(c);
reg3:=getFormats(a);
if (reg3<0) then exit;
sig1:=getSigns(a);
if (sig1<0) then exit;
siz1:=getSizes(a);
if (siz1<0) then exit;
sig2:=getSigns(a);
if (sig2<0) then exit;
siz2:=getSizes(a);
if (siz2<0) then exit;
par1:=getWord(c);
par2:=getWord(c);
if (siz2>siz1) then siz2:=siz1;
reg2:=getRegister(par2,true,true);
if (reg2<0) then exit;
b:=regNames[reg2];
if (siz1>siz2) then begin;
  if (sig1=1) and (sig2=1) then begin;
    case siz2 of
      1:outputLine('extsb r12,'+b,'');
      2:outputLine('extsh r12,'+b,'');
      else exit;
      end;
    end else begin;
    case siz2 of
      1:outputLine('andi. r12,'+b+',0ffh','');
      2:outputLine('andi. r12,'+b+',0ffffh','');
      else exit;
      end;
    end;
  b:='r12';
  end;

if (reg3=3) then begin;
  codeOneLSBconvert(siz2,'r12',b);
  b:='r12';
  end;

if CodeOneMem(par1) then exit;

case siz1 of
  1:outputLine('stb '+b+',0(r10)','');
  2:outputLine('sth '+b+',0(r10)','');
  3:outputLine('stw '+b+',0(r10)','');
  else exit;
  end;
codeOneWrite:=false;
End;


Begin;
CompileOneLine:=True;
oc:=c;d:='';
a:=getWord(c);
if (a='platform') then goto oke;
if (a='proc') then begin;
  outputLine('','');
  d:='proc '+getWord(c);
  goto vege;
  end;
if (a='endp') then begin;
  outputLine('endp',oc);
  outputLine('','');
  goto oke;
  end;
if (a='label') then begin;
  d:=getWord(c)+':';
  goto vege;
  end;
if (a='defb') or (a='defw') or (a='defd') or (a='defq') then begin;
  d:='d'+a[4];
  while (c<>'') do d:=d+','+getWord(c);
  d[3]:=' ';
  goto vege;
  end;
if (a='const') then begin;
  d:=getWord(c)+' equ ';
  d:=d+getWord(c);
  goto vege;
  end;
if (a='align') then begin;
  d:=a+' '+getWord(c);
  goto vege;
  end;
if (a='add') or (a='sub') or (a='or') or (a='xor') or (a='and') then begin;
  d:=a;
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='r10';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  c:=a;
  d:=d+' '+a+','+c+','+b;
  goto vege;
  end;
if (a='mul') then begin;
  a:=getWord(c);
  o:=getSigns(a);
  if (o<0) then exit;
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='r10';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  d:='mullw '+a+','+a+','+b;
  goto vege;
  end;
if (a='div') then begin;
  a:=getWord(c);
  case getSigns(a) of
    1:d:='divw ';
    2:d:='divwu ';
    else exit;
    end;
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='r10';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  d:=d+a+','+a+','+b;
  goto vege;
  end;
if (a='mod') then begin;
  a:=getWord(c);
  case getSigns(a) of
    1:d:='divw ';
    2:d:='divwu ';
    else exit;
    end;
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='r10';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  outputLine(d+'r11,'+a+','+b,oc);
  outputLine('mullw r11,r11,'+b,'');
  outputLine('sub '+a+','+a+',r11','');
  goto oke;
  end;
if (a='not') then begin;
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=regNames[p];
  d:='orc '+a+',r0,'+a;
  goto vege;
  end;
if (a='neg') then begin;
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=regNames[p];
  d:='sub '+a+',r0,'+a;
  goto vege;
  end;
if (a='shl') or (a='shr') then begin;
  if (a='shl') then d:='slw ' else d:='srw ';
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='r10';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  d:=d+a+','+a+','+b;
  goto vege;
  end;
if (a='push') or (a='pop') then begin;
  d:=a;
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i<0) then exit;
  a:=regNames[i];
  if (d='push') then CodeOnePush(a) else CodeOnePop(a);
  goto oke;
  end;
if (a='comp') then begin;
  a:=getWord(c);
  i:=getSigns(a);
  if (i<0) then exit;
  CompareSeenSign:=(i=1);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i<0) then exit;
  d:=regNames[i];
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='r11';
    CodeOneNum(b,a);
    end;
  case o of
    1:if CompareSeenSign then begin;
      outputLine('extsb r10,'+d,'');
      outputLine('extsb r11,'+b,'');
      d:='r10';b:='r11';
      end else begin;
      outputLine('andi. r10,'+d+',0ffh','');
      outputLine('andi. r11,'+b+',0ffh','');
      d:='r10';b:='r11';
      end;
    2:if CompareSeenSign then begin;
      outputLine('extsh r10,'+d,'');
      outputLine('extsh r11,'+b,'');
      d:='r10';b:='r11';
      end else begin;
      outputLine('andi. r10,'+d+',0ffffh','');
      outputLine('andi. r11,'+b+',0ffffh','');
      d:='r10';b:='r11';
      end;
    3:;
    else exit;
    end;
  outputLine('sub r19,'+d+','+b,oc);
  goto oke;
  end;
if (a='move') then begin;
  a:=getWord(c);
  sig1:=getSigns(a);
  if (sig1<0) then exit;
  siz1:=getSizes(a);
  if (siz1<0) then exit;
  sig2:=getSigns(a);
  if (sig2<0) then exit;
  siz2:=getSizes(a);
  if (siz2<0) then exit;
  a:=getWord(c);
  reg1:=getRegister(a,true,true);
  if (reg1<0) then exit;
  a:=getWord(c);
  reg2:=getRegister(a,true,true);
  if (reg2<0) then begin;
    CodeOneNum(regNames[reg1],a);
    goto oke;
    end;
  if (siz1<=siz2) then begin;
    d:='or '+regNames[reg1]+',r0,'+regNames[reg2];
    goto vege;
    end;
  c:=regNames[reg1];
  b:=regNames[reg2];
  if (sig1=1) and (sig2=1) then begin;
    case siz2 of
      1:a:='extsb ';
      2:a:='extsh ';
      else exit;
      end;
    outputLine(a+c+','+b,oc);
    end else begin;
    case siz2 of
      1:a:='0ffh';
      2:a:='0ffffh';
      else exit;
      end;
    outputLine('andi. '+c+','+b+','+a,oc);
    end;
  goto oke;
  end;
if (a='movr') then begin;
  if codeOneRead(c) then exit;
  goto oke;
  end;
if (a='movw') then begin;
  if codeOneWrite(c) then exit;
  goto oke;
  end;
if (a='call') then begin;
  a:=getWord(c);
  if (a='') then exit;
  outputLine('mfspr r10,lr',oc);
  CodeOnePush('r10');
  outputLine('bl offset '+a,oc);
  CodeOnePop('r10');
  outputLine('mtspr lr,r10','');
  goto oke;
  end;
if (a='ret') then begin;
  outputLine('bclr a,eq',oc);
  goto oke;
  end;
if (a='jump') then begin;
  a:=getWord(c);
  if (a='') then exit;
  outputLine('b offset '+a,oc);
  goto oke;
  end;
if (a='cllr') then begin;
  o:=getRegister(c,false,true);
  if (o<0) then exit;
  outputLine('mfspr r10,lr',oc);
  outputLine('mtspr ctr,'+regNames[o],'');
  CodeOnePush('r10');
  outputLine('bcctrl a,eq',oc);
  CodeOnePop('r10');
  outputLine('mtspr lr,r10','');
  goto oke;
  end;
if (a='jmpr') then begin;
  o:=getRegister(c,false,true);
  if (o<0) then exit;
  outputLine('mtspr ctr,'+regNames[o],oc);
  outputLine('bcctr a,eq',oc);
  goto oke;
  end;
if (a='jmpc') then begin;
  a:=getWord(c);
  i:=getCondition(a);
  if (i<0) then exit;
  a:=getWord(c);
  if (a='') then exit;
  case i of
    1:b:='t,gt'; {a}
    2:b:='t,lt'; {b}
    3:b:='f,eq'; {ne}
    4:b:='t,eq'; {e}
    5:b:='f,lt'; {ae}
    6:b:='f,gt'; {be}
    else exit;
    end;
  outputLine('or. r19,r19,r19',oc);
  outputLine('bc '+b+',offset '+a,'');
  goto oke;
  end;
if (a='setc') then begin;
  a:=getWord(c);
  i:=getCondition(a);
  if (i<0) then exit;
  a:=getWord(c);
  p:=getSizes(a);
  if (p<0) then exit;
  a:=getWord(c);
  o:=getRegister(a,true,true);
  if (o<0) then exit;
  b:=regNames[o];
  outputLine('li '+b+',1',oc);
  case i of
    1:a:='t,gt'; {a}
    2:a:='t,lt'; {b}
    3:a:='f,eq'; {ne}
    4:a:='t,eq'; {e}
    5:a:='f,lt'; {ae}
    6:a:='f,gt'; {be}
    else exit;
    end;
  outputLine('or. r19,r19,r19','');
  outputLine('bc '+a+',offset '+getLabelName,'');
  outputLine('li '+b+',0','');
  outputLine(getLabelName+':','');
  goto oke;
  end;
if (a='xchg') then begin;
  a:=getWord(c);
  p:=getSizes(a);
  if (p<0) then exit;
  b:=getWord(c);
  o:=getRegister(b,true,true);
  if (o<0) then exit;
  c:=getWord(c);
  if CodeOneMem(c) then exit;
  case p of
    1:c:='b';
    2:c:='h';
    3:c:='d';
    else exit;
    end;
  b:=regNames[o];
  outputLine('l'+c+'z r11,0(r10)',oc);
  outputLine('st'+c+' '+b+',0(r10)','');
  outputLine('or '+b+',r0,r11','');
  goto oke;
  end;
if (a='addrlod') then begin;
  if CodeOneRead('dudud '+c) then exit;
  goto oke;
  end;
if (a='addrsav') then begin;
  if CodeOneWrite('dudud '+c) then exit;
  goto oke;
  end;
if (a='procaddr') then begin;
  a:=getWord(c);
  o:=getRegister(a,false,true);
  if (o<0) then exit;
  d:=getWord(c);
  if (d='') then exit;
  a:=regNames[o];
  if (d='-') then begin;
    outputLine('or '+a+',r9,r9',oc);
    end else begin;
    outputLine('addi r11,r30,procTable_ofs',oc);
    CodeOneNum(a,d);
    outputLine('slwi '+a+','+a+',2','');
    outputLine('add r11,r11,'+a,'');
    outputLine('lwz '+a+',0(r11)','');
    end;
  goto oke;
  end;
if (a='procallocbeg') then begin;
  a:=getWord(c);
  if (a='') then exit;
  d:=getWord(c);
  if (d='') then exit;
  outputLine('addi r11,r30,procTable_ofs',oc);
  CodeOnePush('r8');
  outputLine('or r1,r9,r9','');
  outputLine('or r9,r8,r8','');
  CodeOneNum('r10',a);
  outputLine('slwi r10,r10,2','');
  outputLine('add r10,r11,r10','');
  outputLine('lwz r11,0(r10)','');
  CodeOnePush('r11');
  CodeOneNum('r10',d);
  outputLine('add r8,r10,r8','');
  CodeOnePush('r1');
  goto oke;
  end;
if (a='procallocend') then begin;
  a:=getWord(c);
  if (a='') then exit;
  d:=getWord(c);
  if (d='') then exit;
  outputLine('addi r11,r30,procTable_ofs',oc);
  CodeOneNum('r10',a);
  outputLine('slwi r10,r10,2','');
  outputLine('add r10,r11,r10','');
  outputLine('stw r9,0(r10)','');
  CodeOnePop('r9');
  goto oke;
  end;
if (a='procfree') then begin;
  a:=getWord(c);
  if (a='') then exit;
  d:=getWord(c);
  if (d='') then exit;
  outputLine('addi r11,r30,procTable_ofs',oc);
  CodeOneNum('r10',a);
  outputLine('slwi r10,r10,2','');
  outputLine('add r11,r11,r10','');
  CodeOnePop('r10');
  outputLine('stw r10,0(r11)','');
  CodeOnePop('r8');
  goto oke;
  end;
if (a='codeofs') then begin;
  a:=getWord(c);
  o:=getRegister(a,false,true);
  if (o<0) then exit;
  a:=getWord(c);
  if (a='') then exit;
  CodeOneNum(regNames[o],'offset '+a);
  goto oke;
  end;
if (a='syscall') then begin;
  d:=c;
  a:=getWord(d);
  if (a='startup') then begin;
    outputLine('program_main:',oc);
    a:=getWord(d);
    o:=bval(a);
    outputLine('procTable_max equ '+bstr(o),'');
    a:=getWord(d);
    outputLine('program_stack equ '+a,'');
    a:=getWord(d);
    outputLine('program_heap equ '+a,'');
    outputLine('freeMemPoint equ 0h','');
    outputLine('consoleSizeX equ 4h','');
    outputLine('consoleSizeY equ 6h','');
    outputLine('dummyBuffer equ 10h','');
    outputLine('procTable_ofs equ 20h','');
    outputLine('firstFreeMem equ '+bstr((o*4)+$20),'');    goto oke;
    end;
  c:='--- '+c;
  xtSetPos(ttbl,0);
  repeat
    if xtEOF(ttbl) then exit;
    a:=xtReadLn(ttbl,255);
    until (a=c);
  a:=';'+oc;
  repeat
    kicserel('@_',getLabelName,a);
    xtWriteLn(tout,a);
    if xtEOF(ttbl) then exit;
    a:=xtReadLn(ttbl,255);
    until (a='---');
  goto oke;
  end;

Exit;
vege:
outputLine(d,oc);
oke:
CompileOneLine:=False;
End;


Label f1,f2;
Var
  i:LongInt;
  a,b:String;
BEGIN;
WriteLn('Virtual Machine Compiler v1.0, done by Mc at '#%date' '#%time'.');
WriteLn('platform: BugOS PowerPC (sasm syntax)');
a:=paramStr(1);
b:=paramStr(2);
if (a='') or (b='') then begin;
  WriteLn('using: compiler.code <source> <object> [table]');
  Halt(1);
  end;
if (xtOpen(ttbl,getBaseName,true)<>0) then begin;
  WriteLn('error operning source table!');
  Halt(1);
  end;
if (xtOpen(tinp,a,true)<>0) then begin;
  WriteLn('error opening source file!');
  Halt(2);
  end;
xErase(b);
xCreate(b);
if (xtOpen(tout,b,false)<>0) then begin;
  WriteLn('error opening target file!');
  Halt(2);
  end;
i:=0;
WriteLn('source: '+a);
WriteLn('target: '+b);
WriteLn('compiling...');
CompileOneLine('syscall @compiler prefix-code',-1);
f1:
if xtEOF(tinp) then goto f2;
inc(i);
a:=xtReadLn(tinp,255);
a:=kicsi(a);
if (a='') then goto f1;
if (copy(a,1,1)=';') then begin;
  outputLine(a,'');
  goto f1;
  end;
Write(BStr(i)+#13);
if not CompileOneLine(a,i) then goto f1;
WriteLn('position: '+BStr(i));
WriteLn('contents: "'+a+'"');
WriteLn('invalid instruction, terminating!');
Halt(3);
f2:
CompileOneLine('syscall @compiler postfix-code',-2);
xtClose(tout);
WriteLn('successful!');
END.