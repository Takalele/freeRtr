{$stack 1k}
{$heap 16k}
{$sysinc system.inc}
{$sysinc param.inc}
{$sysinc alap.inc}
{$sysinc filesys.inc}
{$sysinc filesys2.inc}
{$sysinc textfile.inc}
Const
  regNames:array[1..6] of string[3]=('a0','a1','a2','a3','v0','v1');
  CompareSeenSign:Boolean=true;
Var tout,tinp,ttbl:xtText;


Procedure outputLine(a,b:String);
Begin;
if (b<>'') then begin;
  while (length(a)<30) do a:=a+' ';
  a:=a+' ;'+b;
  end;
xtWriteLn(tout,a);
End;

Function getBaseName:String;
Var
  i,o:Word;
  a:String;
Begin;
a:=ParamStr(3);
if (a<>'') then begin; getBaseName:=a;exit; end;
a:=ParamStr(0);
o:=0;
for i:=1 to length(a) do if (a[i]='\') then o:=i;
a:=copy(a,o+1,666);
o:=666;
for i:=1 to length(a) do if (a[i]='.') then o:=i;
a:='c:\sources\developer\vm-compiler\'+copy(a,1,o-1)+'.table';
getBaseName:=a;
End;

Function getWord(var a:String):String;
Var i:Word;
Begin;
i:=pos(' ',a);
if (i<1) then i:=$666;
getWord:=copy(a,1,i-1);
a:=copy(a,i+1,$666);
End;

function getSizes(var a:string):integer;
var i:integer;
begin;
a[length(a)+1]:=#255;
case a[1] of
  'b':i:=1;
  'w':i:=2;
  'd':i:=3;
  'q':i:=4;
  else i:=-1;
  end;
delete(a,1,1);
getSizes:=i;
end;

function getSigns(var a:string):integer;
var i:integer;
begin;
a[length(a)+1]:=#255;
case a[1] of
  's':i:=1;
  'u':i:=2;
  else i:=-1;
  end;
delete(a,1,1);
getSigns:=i;
end;

function getFormats(var a:string):integer;
var i:integer;
begin;
a[length(a)+1]:=#255;
case a[1] of
  'd':i:=1;
  'm':i:=2;
  'l':i:=3;
  else i:=-1;
  end;
delete(a,1,1);
getFormats:=i;
end;

function getRegister(a:string;dat,ptr:boolean):integer;
var i:integer;
begin;
i:=-1;
if dat then begin;
  if (a='a') then i:=1;
  if (a='b') then i:=2;
  if (a='c') then i:=3;
  if (a='d') then i:=4;
  end;
if ptr then begin;
  if (a='src') then i:=5;
  if (a='trg') then i:=6;
  end;
getRegister:=i;
end;

function getCondition(a:string):integer;
var i:integer;
begin;
i:=-1;
if (a='nbe') then a:='a';
if (a='nae') then a:='b';
if (a='nb') then a:='ae';
if (a='na') then a:='be';
if (a='a') then i:=1;
if (a='b') then i:=2;
if (a='ne') then i:=3;
if (a='e') then i:=4;
if (a='ae') then i:=5;
if (a='be') then i:=6;
getCondition:=i;
end;




Function CompileOneLine(c:String;lineNum:LongInt):Boolean;
Label oke,vege;
Const
  byteOrder:array[1..3,1..2,1..4] of byte=(
    ((0,9,9,9),(0,9,9,9)),
    ((0,1,9,9),(1,0,9,9)),
    ((0,1,2,3),(3,2,1,0)));
  byteSizes:array[1..4] of byte=(1,2,4,0);
Var
  siz1,siz2,siz3:integer;
  sig1,sig2,sig3:integer;
  reg1,reg2,reg3:integer;
  par1,par2:String;
  oc,a,b,d:String;
  i,o,p:LongInt;

Procedure CodeOneNum(r,n:String);
Var i:LongInt;
Begin;
i:=BVal(n);
if (i<>0) or (n='0') then begin;
  if (i shr 16=0) then n:='r0' else begin;
    outputLine('lui '+r+','+BStr(i shr 16),'');
    n:=r;
    end;
  outputLine('ori '+r+','+n+','+BStr(i and $ffff),'');
  exit;
  end;
outputLine('lui '+r+','+n,'');
outputLine('ori '+r+','+r+','+n,'');
End;

Procedure CodeOnePush(r:String);
Begin;
outputLine('addiu sp,sp,-4','');
outputLine('sw '+r+',0,sp','push '+r);
End;

Procedure CodeOnePop(r:String);
Begin;
outputLine('lw '+r+',0,sp','pop '+r);
outputLine('addiu sp,sp,4','');
End;

Function CodeOneMem(a:string):Boolean;
Var o:longint;
Begin;
CodeOneMem:=true;
if (copy(a,1,1)<>'[') then exit;
if (copy(a,length(a),1)<>']') then exit;
a:=copy(a,2,length(a)-2);
if (length(a)=3) then a:=a+'+0';
o:=getRegister(copy(a,1,3),false,true);
if (o<1) then exit;
a:=copy(a,4,$666);
if (a='+0') or (a='-0') then a:='0';
CodeOneNum('t0',a);
outputLine('addu t0,t0,'+regNames[o],'');
CodeOneMem:=false;
End;

Function codeOneRead(c:String):Boolean;
Var i:LongInt;
Begin;
codeOneRead:=true;
a:=getWord(c);
reg3:=getFormats(a);
if (reg3<0) then exit;
sig1:=getSigns(a);
if (sig1<0) then exit;
siz1:=getSizes(a);
if (siz1<0) then exit;
sig2:=getSigns(a);
if (sig2<0) then exit;
siz2:=getSizes(a);
if (siz2<0) then exit;
par1:=getWord(c);
par2:=getWord(c);
if (siz2>siz1) then siz2:=siz1;
reg1:=getRegister(par1,true,true);
if (reg1<0) then exit;
b:=regNames[reg1];
if CodeOneMem(par2) then exit;
dec(reg3);
if (reg3<1) then reg3:=1;
if (siz1>1) and (sig1=1) and (sig2=1) then a:='lb ' else a:='lbu ';
outputLine(a+b+','+BStr(byteOrder[siz2][reg3][1])+',t0',oc);
for i:=2 to byteSizes[siz2] do begin;
  outputLine('sll '+b+','+b+',8','');
  outputLine('lbu t1,'+BStr(byteOrder[siz2][reg3][i])+',t0','');
  outputLine('or '+b+','+b+',t1','');
  end;
codeOneRead:=false;
End;

Function codeOneWrite(c:String):Boolean;
Var i:LongInt;
Begin;
codeOneWrite:=True;
a:=getWord(c);
reg3:=getFormats(a);
if (reg3<0) then exit;
sig1:=getSigns(a);
if (sig1<0) then exit;
siz1:=getSizes(a);
if (siz1<0) then exit;
sig2:=getSigns(a);
if (sig2<0) then exit;
siz2:=getSizes(a);
if (siz2<0) then exit;
par1:=getWord(c);
par2:=getWord(c);
if (siz2>siz1) then siz2:=siz1;
reg2:=getRegister(par2,true,true);
if (reg2<0) then exit;
b:=regNames[reg2];
if CodeOneMem(par1) then exit;
dec(reg3);
if (reg3<1) then reg3:=1;
case siz2 of
  1:i:=24;
  2:i:=16;
  3:i:=0;
  else exit;
  end;
if (siz1=siz2) then i:=0;
if (i>0) then begin;
  if (siz1>siz2) and (sig1=1) and (sig2=1) then begin;
    a:=BStr(i);
    outputLine('sll t1,'+b+','+a,oc);
    outputLine('sra t1,t1,'+a,'');
    end else begin;
    outputLine('andi t1,'+b+','+BStr((1 shl (32-i))-1),oc);
    end;
  end else outputLine('or t1,r0,'+b,oc);
for i:=byteSizes[siz2] downto 1 do begin;
  outputLine('sb t1,'+BStr(byteOrder[siz2][reg3][i])+',t0','');
  if (i>1) then outputLine('srl t1,t1,8','');
  end;
codeOneWrite:=False;
End;


Begin;
CompileOneLine:=True;
oc:=c;d:='';
a:=getWord(c);
if (a='platform') then goto oke;
if (a='proc') then begin;
  outputLine('','');
  d:='proc '+getWord(c);
  goto vege;
  end;
if (a='endp') then begin;
  outputLine('endp',oc);
  outputLine('','');
  goto oke;
  end;
if (a='label') then begin;
  d:=getWord(c)+':';
  goto vege;
  end;
if (a='defb') or (a='defw') or (a='defd') or (a='defq') then begin;
  d:='d'+a[4];
  while (c<>'') do d:=d+','+getWord(c);
  d[3]:=' ';
  goto vege;
  end;
if (a='const') then begin;
  d:=getWord(c)+' equ ';
  d:=d+getWord(c);
  goto vege;
  end;
if (a='align') then begin;
  d:=a+' '+getWord(c);
  goto vege;
  end;
if (a='add') or (a='sub') or (a='or') or (a='xor') or (a='and') then begin;
  if (a='sub') or (a='add') then a:=a+'u';
  d:=a+' ';
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='t0';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  d:=d+a+','+a+','+b;
  goto vege;
  end;
if (a='mul') then begin;
  a:=getWord(c);
  case getSigns(a) of
    1:d:='mult ';
    2:d:='multu ';
    else exit;
    end;
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='t0';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  outputLine(d+a+','+b,'');
  d:='mflo '+a;
  goto vege;
  end;
if (a='div') then begin;
  a:=getWord(c);
  case getSigns(a) of
    1:d:='div ';
    2:d:='divu ';
    else exit;
    end;
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='t0';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  outputLine(d+a+','+b,'');
  d:='mflo '+a;
  goto vege;
  end;
if (a='mod') then begin;
  a:=getWord(c);
  case getSigns(a) of
    1:d:='div ';
    2:d:='divu ';
    else exit;
    end;
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='t0';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  outputLine(d+a+','+b,'');
  d:='mfhi '+a;
  goto vege;
  end;
if (a='not') or (a='neg') then begin;
  if (a='not') then d:='nor ' else d:='subu ';
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=regNames[p];
  d:=d+a+',r0,'+a;
  goto vege;
  end;
if (a='shl') or (a='shr') then begin;
  if (a='shl') then d:='sllv ' else d:='srlv ';
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  p:=getRegister(a,true,true);
  if (p<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='t0';
    CodeOneNum(b,a);
    end;
  a:=regNames[p];
  d:=d+a+','+a+','+b;
  goto vege;
  end;
if (a='push') or (a='pop') then begin;
  d:=a;
  a:=getWord(c);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i<0) then exit;
  a:=regNames[i];
  if (d='push') then CodeOnePush(a) else CodeOnePop(a);
  goto oke;
  end;
if (a='comp') then begin;
  a:=getWord(c);
  i:=getSigns(a);
  if (i<0) then exit;
  CompareSeenSign:=(i=1);
  o:=getSizes(a);
  if (o<0) then exit;
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i<0) then exit;
  outputLine('or t7,r0,'+regNames[i],oc);
  a:=getWord(c);
  i:=getRegister(a,true,true);
  if (i>0) then b:=regNames[i] else begin;
    b:='t0';
    CodeOneNum(b,a);
    end;
  case o of
    1:i:=24;
    2:i:=16;
    3:i:=0;
    else exit;
    end;
  if (i>0) then begin;
    if CompareSeenSign then begin;
      a:=BStr(i);
      outputLine('sll t0,'+b+','+a,'');
      outputLine('sll t7,t7,'+a,'');
      outputLine('sra t0,t0,'+a,'');
      outputLine('sra t7,t7,'+a,'');
      end else begin;
      a:=BStr((1 shl (32-i))-1);
      outputLine('andi t0,'+b+','+a,'');
      outputLine('andi t7,t7,'+a,'');
      end;
    b:='t0';
    end;
  outputLine('subu t7,t7,'+b,'');
  goto oke;
  end;
if (a='move') then begin;
  a:=getWord(c);
  sig1:=getSigns(a);
  if (sig1<0) then exit;
  siz1:=getSizes(a);
  if (siz1<0) then exit;
  sig2:=getSigns(a);
  if (sig2<0) then exit;
  siz2:=getSizes(a);
  if (siz2<0) then exit;
  a:=getWord(c);
  reg1:=getRegister(a,true,true);
  if (reg1<0) then exit;
  a:=getWord(c);
  reg2:=getRegister(a,true,true);
  if (reg2<0) then begin;
    CodeOneNum(regNames[reg1],a);
    goto oke;
    end;
  if (siz1<=siz2) then begin;
    d:='or '+regNames[reg1]+',r0,'+regNames[reg2];
    goto vege;
    end;
  case siz2 of
    1:i:=24;
    2:i:=16;
    else exit;
    end;
  c:=regNames[reg1];
  b:=regNames[reg2];
  if (sig1=1) and (sig2=1) then begin;
    a:=BStr(i);
    outputLine('sll '+c+','+b+','+a,oc);
    outputLine('sra '+c+','+c+','+a,'');
    end else begin;
    outputLine('andi '+c+','+b+','+BStr((1 shl (32-i))-1),oc);
    end;
  goto oke;
  end;
if (a='movr') then begin;
  if codeOneRead(c) then exit;
  goto oke;
  goto oke;
  end;
if (a='movw') then begin;
  if codeOneWrite(c) then exit;
  goto oke;
  end;
if (a='call') then begin;
  a:=getWord(c);
  if (a='') then exit;
  CodeOnePush('ra');
  outputLine('jal offset '+a,oc);
  outputLine('noop','');
  CodeOnePop('ra');
  goto oke;
  end;
if (a='ret') then begin;
  outputLine('jr ra',oc);
  outputLine('noop','');
  goto oke;
  end;
if (a='jump') then begin;
  a:=getWord(c);
  if (a='') then exit;
  outputLine('j offset '+a,oc);
  outputLine('noop','');
  goto oke;
  end;
if (a='cllr') then begin;
  o:=getRegister(c,false,true);
  if (o<0) then exit;
  CodeOnePush('ra');
  outputLine('jalr ra,'+regNames[o],oc);
  outputLine('noop','');
  CodeOnePop('ra');
  goto oke;
  end;
if (a='jmpr') then begin;
  o:=getRegister(c,false,true);
  if (o<0) then exit;
  outputLine('jr '+regNames[o],oc);
  outputLine('noop','');
  goto oke;
  end;
if (a='jmpc') then begin;
  a:=getWord(c);
  i:=getCondition(a);
  if (i<0) then exit;
  a:=getWord(c);
  if (a='') then exit;
  case i of
    1:b:='bgtz t7';             {a}
    2:b:='bltz t7';             {b}
    3:b:='bne t7,r0';           {ne}
    4:b:='beq t7,r0';           {e}
    5:b:='bgez t7';             {ae}
    6:b:='blez t7';             {be}
    end;
  outputLine(b+',offset '+a,oc);
  outputLine('noop','');
  goto oke;
  end;
if (a='setc') then begin;
  a:=getWord(c);
  i:=getCondition(a);
  if (i<0) then exit;
  a:=getWord(c);
  p:=getSizes(a);
  if (p<0) then exit;
  a:=getWord(c);
  o:=getRegister(a,true,true);
  if (o<0) then exit;
  a:=regNames[o];
  if (i in [1,3,4,5]) then outputLine('subu t0,r0,t7','');
  if (i in [3,4]) then begin;
    if (i=3) then b:='0' else b:='1';
    outputLine('slti t1,t7,'+b,'');
    outputLine('slti t0,t0,'+b,'');
    end;
  case i of
    1:d:='slti '+a+',t0,0';     {a}
    2:d:='slti '+a+',t7,0';     {b}
    3:d:='or '+a+',t0,t1';      {ne}
    4:d:='and '+a+',t0,t1';     {e}
    5:d:='slti '+a+',t0,1';     {ae}
    6:a:='slti '+a+',t7,1';     {be}
    end;
  goto vege;
  end;
if (a='xchg') then begin;
  a:=getWord(c);
  b:=getWord(c);
  c:=getWord(c);
  o:=getRegister(a,true,true);
  if (o<0) then exit;
  outputLine('or t2,r0,'+regNames[o],oc);
  if CodeOneRead('du'+a+'u'+a+' '+c+' '+b) then exit;
  c:=oc;getWord(c);
  a:=getWord(c);
  b:=getWord(c);
  c:=getWord(c);
  o:=getRegister(a,true,true);
  if (o<0) then exit;
  outputLine('or t3,r0,'+regNames[o],oc);
  outputLine('or '+regNames[o]+',r0,t2',oc);
  if CodeOneWrite('du'+a+'u'+a+' '+b+' '+c) then exit;
  c:=oc;getWord(c);
  a:=getWord(c);
  b:=getWord(c);
  c:=getWord(c);
  o:=getRegister(a,true,true);
  if (o<0) then exit;
  outputLine('or '+regNames[o]+',r0,t3',oc);
  goto oke;
  end;
if (a='addrlod') then begin;
  if CodeOneRead('dudud '+c) then exit;
  goto oke;
  end;
if (a='addrsav') then begin;
  if CodeOneWrite('dudud '+c) then exit;
  goto oke;
  end;
if (a='procaddr') then begin;
  a:=getWord(c);
  o:=getRegister(a,false,true);
  if (o<0) then exit;
  d:=getWord(c);
  if (d='') then exit;
  a:=regNames[o];
  if (d='-') then begin;
    outputLine('or '+a+',r0,at',oc);
    end else begin;
    CodeOneNum(a,d);
    outputLine('addiu t0,gp,procTable_ofs','');
    outputLine('sll '+a+','+a+',2',oc);
    outputLine('addu t0,t0,'+a,'');
    outputLine('lw '+a+',0,t0','');
    end;
  goto oke;
  end;
if (a='procallocbeg') then begin;
  a:=getWord(c);
  if (a='') then exit;
  d:=getWord(c);
  if (d='') then exit;
  CodeOneNum('t0',a);
  outputLine('addiu t1,gp,procTable_ofs','');
  outputLine('sll t0,t0,2',oc);
  outputLine('addu t0,t0,t1','');
  outputLine('lw t1,0,t0','');
  CodeOnePush('t1');
  CodeOnePush('at');
  CodeOneNum('t0',d);
  outputLine('lw at,freeMemPoint,gp','');
  outputLine('addu t0,at,t0','');
  outputLine('sw t0,freeMemPoint,gp','');
  goto oke;
  end;
if (a='procallocend') then begin;
  a:=getWord(c);
  if (a='') then exit;
  d:=getWord(c);
  if (d='') then exit;
  CodeOneNum('t0',a);
  outputLine('addiu t1,gp,procTable_ofs','');
  outputLine('sll t0,t0,2',oc);
  outputLine('addu t0,t0,t1','');
  outputLine('sw at,0,t0','');
  CodeOnePop('at');
  goto oke;
  end;
if (a='procfree') then begin;
  a:=getWord(c);
  if (a='') then exit;
  d:=getWord(c);
  if (d='') then exit;
  CodeOneNum('t0',a);
  outputLine('addiu t1,gp,procTable_ofs','');
  outputLine('sll t0,t0,2',oc);
  outputLine('addu t0,t0,t1','');
  CodeOnePop('t1');
  outputLine('sw t1,0,t0','');
  CodeOneNum('t0',d);
  outputLine('lw t1,freeMemPoint,gp','');
  outputLine('subu t0,t1,t0','');
  outputLine('sw t0,freeMemPoint,gp','');
  goto oke;
  end;
if (a='codeofs') then begin;
  a:=getWord(c);
  o:=getRegister(a,false,true);
  if (o<0) then exit;
  a:=getWord(c);
  if (a='') then exit;
  CodeOneNum(regNames[o],'offset '+a);
  goto oke;
  end;
if (a='syscall') then begin;
  d:=c;
  a:=getWord(d);
  if (a='startup') then begin;
    outputLine('program_main:',oc);
    a:=getWord(d);
    o:=bval(a);
    outputLine('procTable_max equ '+bstr(o),'');
    a:=getWord(d);
    outputLine('program_stack equ '+a,'');
    a:=getWord(d);
    outputLine('program_heap equ '+a,'');
    outputLine('freeMemPoint equ 0h','');
    outputLine('consoleSizeX equ 4h','');
    outputLine('consoleSizeY equ 6h','');
    outputLine('dummyBuffer equ 10h','');
    outputLine('procTable_ofs equ 20h','');
    outputLine('firstFreeMem equ '+bstr((o*4)+$20),'');
    goto oke;
    end;
  c:='--- '+c;
  xtSetPos(ttbl,0);
  repeat
    if xtEOF(ttbl) then exit;
    a:=xtReadLn(ttbl,255);
    until (a=c);
  d:='autolabel'+BStr(lineNum)+'_';
  a:=';'+oc;
  repeat
    kicserel('@_',d,a);
    xtWriteLn(tout,a);
    if xtEOF(ttbl) then exit;
    a:=xtReadLn(ttbl,255);
    until (a='---');
  goto oke;
  end;

Exit;
vege:
outputLine(d,oc);
oke:
CompileOneLine:=False;
End;


Label f1,f2;
Var
  i:LongInt;
  a,b:String;
BEGIN;
WriteLn('Virtual Machine Compiler v1.0, done by Mc at '#%date' '#%time'.');
WriteLn('platform: BugOS MiPS (sasm syntax)');
a:=paramStr(1);
b:=paramStr(2);
if (a='') or (b='') then begin;
  WriteLn('using: compiler.code <source> <object> [table]');
  Halt(1);
  end;
if (xtOpen(ttbl,getBaseName,true)<>0) then begin;
  WriteLn('error operning source table!');
  Halt(1);
  end;
if (xtOpen(tinp,a,true)<>0) then begin;
  WriteLn('error opening source file!');
  Halt(2);
  end;
xErase(b);
xCreate(b);
if (xtOpen(tout,b,false)<>0) then begin;
  WriteLn('error opening target file!');
  Halt(2);
  end;
i:=0;
WriteLn('source: '+a);
WriteLn('target: '+b);
WriteLn('compiling...');
CompileOneLine('syscall @compiler prefix-code',-1);
f1:
if xtEOF(tinp) then goto f2;
inc(i);
a:=xtReadLn(tinp,255);
a:=kicsi(a);
if (a='') then goto f1;
if (copy(a,1,1)=';') then begin;
  outputLine(a,'');
  goto f1;
  end;
Write(BStr(i)+#13);
if not CompileOneLine(a,i) then goto f1;
WriteLn('position: '+BStr(i));
WriteLn('contents: "'+a+'"');
WriteLn('invalid instruction, terminating!');
Halt(3);
f2:
CompileOneLine('syscall @compiler postfix-code',-2);
xtClose(tout);
WriteLn('successful!');
END.