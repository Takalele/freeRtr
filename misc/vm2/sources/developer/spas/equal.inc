Const StandardEndings=#13';'#13'end'#13'else'#13'until'#13;

Function NegateOneJumpCondition(a:String):String;
Begin;
if (copy(a,1,1)='n') then delete(a,1,1) else a:='n'+a;
NegateOneJumpCondition:=a;
End;

Procedure SkipCommaBlock;
Label f1;
Var a:String;
Begin;
f1:
a:=GetNextWord;
if (a=';') then goto f1;
if (copy(a,1,1)='{') then goto f1;
PutBackWord(a);
End;

Function CodeOneEqualation(extra:string;var tm1,tm2,tm3:MemoryOneRecord):String;
{1-inc/dec, 2-return}
Label f1,f2;
Var
  a,b:String;
  c:Char;
  i,o,p:LongInt;
Begin;
if (extra='') then begin;
  a:=ReadUpExpression(#13':'#13'='#13';'#13,tm1,tm2);
  if (a<>':') then SignError(': expected');
  if (GetNextWord<>'=') then SignError('= expected');
  PutBackWord(ReadUpExpression(StandardEndings,tm2,tm3));
  MemoryAppend(tm2);
  a:=CodeOneCalc(tm1,tm2,tm3,4,$80);
  b:=a;
  str2bin(a,o,sizeof(o));
  MemoryDelLast(tm2);
  if (o=DatType_untp) then begin;
    str2bin(copy(a,5,255),i,sizeof(i));
    PutLine('push '+DataSizesList[defOffsSize]+' trg');
    a:=CodeOneCalc(tm2,tm1,tm3,4,1);
    str2bin(a,o,sizeof(o));
    if (o<>DatType_untp) then SignError('type mismatch');
    str2bin(copy(a,5,255),o,sizeof(o));
    if (o<>i) then SignError('type mismatch');
    PutLine('pop '+DataSizesList[defOffsSize]+' trg');
    a:='u'+DataSizesList[defOffsSize];
    PutLine('move '+a+a+' c '+BStr(o));
    PutLine('sysCall memCopy');
    exit;
    end;
  if (o=DatType_pntr) then begin;
    PutLine('push '+DataSizesList[defOffsSize]+' trg');
    a:=CodeOneCalc(tm2,tm1,tm3,4,1);
    str2bin(a,o,sizeof(o));
    if (o<>DatType_pntr) and (o<>DatType_untp) then SignError('type mismatch');
    PutLine('pop '+DataSizesList[defOffsSize]+' trg');
    PutLine('addrSav [trg] src');
    exit;
    end;
  i:=GetStandardTypeCast(a);
  if (i=1) then begin;
    b:=GetStandardIntPrefix(a);
    PutLine('push '+DataSizesList[defOffsSize]+' trg');
    a:=CodeOneCalc(tm2,tm1,tm3,1,o);
    if (copy(a,1,1)<>#1) then SignError('out of memory');
    PutLine('pop '+DataSizesList[defOffsSize]+' trg');
    PutLine('movW d'+b+b+' [trg] a');
    exit;
    end;
  if (i<>2) then SignError('error in expression');
  PutLine('push '+DataSizesList[defOffsSize]+' trg');
  i:=GetStandardTypeLen(b);
  a:=CodeOneCalc(tm2,tm1,tm3,2,i);
  if (copy(a,1,1)<>#2) then SignError('out of memory');
  PutLine('pop '+DataSizesList[defOffsSize]+' trg');
  if (o=DatType_char) then begin;
    PutLine('movR dubub a [src+1]');
    PutLine('movW dubub [trg] a');
    Exit;
    end;
  str2bin(copy(b,5,255),o,sizeof(o));
  a:=DataSizesList[defIntgSize];
  PutLine('move u'+a+'u'+a+' c '+BStr(o-1));
  PutLine('call StringCopy');
  Exit;
  end;
if (copy(extra,1,1)=#2) then begin;
  delete(extra,1,1);
  str2bin(extra,p,sizeof(p));
  o:=ord(extra[5]);
  if (o=0) then SignError('invalid procedure or function reference');
  if (GetNextWord<>':') then SignError(': expected');
  if (GetNextWord<>'=') then SignError('= expected');
  PutBackWord(ReadUpExpression(StandardEndings,tm1,tm2));
  a:=chr(o)+#0#0#0;
  i:=GetStandardTypeCast(a);
  case i of
    1:a:=CodeOneCalc(tm1,tm2,tm3,i,o);
    2:a:=CodeOneCalc(tm1,tm2,tm3,i,GetStandardTypeLen(a));
    else a:='';
    end;
  if (copy(a,1,1)<>chr(i)) then SignError('out of memory');
  PutOutProcAddr('trg',GetNameProc(p),'res');
  if (i=1) then begin;
    a:=GetStandardIntPrefix(chr(o)+#0#0#0);
    PutLine('movW d'+a+a+' [trg] a');
    Exit;
    end;
  if (o=DatType_char) then begin;
    PutLine('movR dubub a [src+1]');
    PutLine('movW dubub [trg] a');
    Exit;
    end;
  if (i<>2) then SignError('error in expression');
  a:='u'+DataSizesList[defOffsSize];
  i:=GetStandardTypeLen(chr(o)+#0#0#0);
  PutLine('move '+a+a+' c '+BStr(i-1));
  PutLine('call StringCopy');
  Exit;
  end;
if (copy(extra,1,1)=#1) then begin;
  c:=extra[2];extra:='';
  a:=ReadUpExpression(#13')'#13','#13,tm1,tm3);
  if (a<>',') then begin;
    PutBackWord(a);
    PutBackWord('$1');
    end;
  a:=ReadUpExpression(#13')'#13,tm2,tm3);
  MemoryAppend(tm2);
  a:=CodeOneCalc(tm1,tm2,tm3,4,$80);
  str2bin(a,o,sizeof(o));
  b:=GetStandardIntPrefix(a);
  MemoryDelLast(tm2);
  PutLine('push '+DataSizesList[defOffsSize]+' trg');
  a:=CodeOneCalc(tm2,tm1,tm3,1,o);
  if (copy(a,1,1)<>#1) then SignError('out of memory');
  PutLine('pop '+DataSizesList[defOffsSize]+' trg');
  PutLine('movR d'+b+b+' b [trg]');
  case c of
    #1:a:='add';
    #2:a:='sub';
    else SignError('out of memory');
    end;
  PutLine(a+' '+b[2]+' b a');
  PutLine('movW d'+b+b+' [trg] b');
  Exit;
  end;

SignError('error in expression');
End;


Procedure UnpackDirectives(Var a,b:String);
Var i:Word;
Begin;
a:=xLevesz(UnPlugString(b));
delete(a,1,1);
i:=pos(' ',a);
if (i=0) then i:=length(a)+1;
b:=copy(a,i+1,255);
a:=kicsi(copy(a,1,i-1));
End;

Function ProcessDefinitions(cmd,par:String):Boolean;
Label okes,skip;
Var
  i:Word;
  a:String;
Begin;
ProcessDefinitions:=False;
par:=kicsi(par);
i:=pos(#13+par+#13,DefinitionsList);
if (cmd='$define') then begin;
  if (i<>0) then goto okes;
  DefinitionsList:=DefinitionsList+par+#13;
  if (length(DefinitionsList)>250) then SignError('too much $define identifier');
  goto okes;
  end;
if (cmd='$error') then begin;
  SignError('$error: '+par);
  end;
if (cmd='$undef') then begin;
  if (i=0) then goto okes;
  inc(i);
  delete(DefinitionsList,i,length(par)+1);
  goto okes;
  end;
if (cmd='$ifdef') then begin;
  if (i=0) then goto skip;
  goto okes;
  end;
if (cmd='$ifndef') then begin;
  if (i<>0) then goto skip;
  goto okes;
  end;
if (cmd='$else') then goto skip;
if (cmd='$endif') then goto okes;
Exit;
skip:
a:=GetNextWord;
if (a='') then SignError('unexpected end of file in $ifdef expression');
i:=pos(' ',a);
if (i=0) then i:=length(a)+1;
a:=Kicsi(copy(a,1,i-1));
if (a='{$else') or (a='{$endif') then goto okes;
goto skip;
okes:
ProcessDefinitions:=True;
End;

Procedure ProcessAsmBlocks;
Label f1,f2;
Var
  a,b,c:String;
  i,o:LongInt;
Begin;
b:=kicsi(GetNextWord);
if (b='varaddr') then begin;
  b:=kicsi(GetNextWord);
  c:=GetNextWord;
  if (c='@') then c:=c+GetNextWord;
  if (GetNextWord<>';') then SignError('; expected');
  c:=kicsi(c);
  if (c='@result') then begin;
    PutOutProcAddr(b,GetNameProc(CurrProcNum),'res');
    Exit;
    end;
  i:=MemoryFind(c,MemType_var,true,MemData1^);
  if (i<0) then SignError('variable identifier expected');
  o:=FindOwnerProc(i,true,MemData1^);
  PutOutProcAddr(b,GetNameProc(o),GetNameVar(i));
  Exit;
  end;
b:=b+' ';
f1:
a:=GetNextChar(false);
if (a='') then SignError('assembler line exceeds line');
if (a='#') then begin;
  a:=GetNextChar(false);
  if (a='') then goto f1;
  a:=BStr(Ord(a[1]));
  end;
if (a=';') then goto f2;
b:=b+a;
goto f1;
f2:
b:=UnPlugString(' '+b+' ');
b:=copy(b,2,length(b)-2);
kicserel('@',GetNameProc(CurrProcNum)+'asm_',b);
kicserel('?',DataSizesList[defOffsSize],b);
PutLine(b);
End;




Procedure CompileStatements(ending:String;breakL,contnL:LongInt);
Label f1,f2,f3,vege;
Var
  a,b:String;
  i,o,p,q:LongInt;
Begin;
goto f2;
f1:
if (ending='') then goto vege;
f2:
ExpressionBegin:=CurrentFileLin;
b:=GetNextWord;a:=kicsi(b);
if (a='') then SignError('unexpected end of file in statement block');
if (a=';') then goto f1;
if (copy(a,1,1)='{') then begin;
  UnpackDirectives(a,b);
  if ProcessDefinitions(a,b) then goto f2;
  goto f2;
  end;
if (a='begin') then begin;
  CompileStatements('end',breakL,contnL);
  goto f1;
  end;
if (a='asm') then begin;
  ProcessAsmBlocks;
  goto f1;
  end;
if (a='goto') then begin;
  a:=GetNextWord;
  i:=MemoryFind(a,MemType_label,false,MemData1^);
  if (i<0) then SignError('label not found: '+a);
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameLabel(MemoryCurPos));
  goto f1;
  end;
if (a='exit') then begin;
  PutLine('jump '+GetNameProc(CurrProcNum)+'end');
  goto f1;
  end;
if (a='break') then begin;
  if (breakL<0) then SignError('no enclosing for, while, or repeat');
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(breakL));
  goto f1;
  end;
if (a='continue') then begin;
  if (contnL<0) then SignError('no enclosing for, while, or repeat');
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(contnL));
  goto f1;
  end;
if (a='for') then begin;
  p:=GetTempNumVarNum;GetTempNumVarNum;
  ReadUpExpression(#13':'#13,MemData1^,MemData2^);
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,4,1);
  if (GetStandardTypeCast(a)<>1) then SignError('integer variable expected');
  b:=copy(a,1,4);
  PutOutProcAddr('trg',GetNameProc(CurrProcNum),GetNameTmpNum(p));
  PutLine('addrSav [trg] src');
  if (GetNextWord<>'=') then SignError('= expected');
  a:=ReadUpExpression(#13'to'#13'downto'#13,MemData1^,MemData2^);
  if (kicsi(a)='to') then i:=1 else i:=0;
  b:=b+chr(i);
  str2bin(b,i,sizeof(i));
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,1,i);
  if (copy(a,1,1)<>#1) then SignError('out of memory');
  PutOutProcAddr('src',GetNameProc(CurrProcNum),GetNameTmpNum(p));
  PutLine('addrLod src [src]');
  a:=GetStandardIntPrefix(b);
  PutLine('movW d'+a+a+' [src] a');
  ReadUpExpression(#13'do'#13,MemData1^,MemData2^);
  str2bin(b,i,sizeof(i));
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,1,i);
  if (copy(a,1,1)<>#1) then SignError('out of memory');
  a:=GetStandardIntPrefix(b);
  PutLine('move '+a+a+' b a');
  PutOutProcAddr('src',GetNameProc(CurrProcNum),GetNameTmpNum(p+1));
  PutLine('movW d'+a+a+' [src] a');
  PutOutProcAddr('src',GetNameProc(CurrProcNum),GetNameTmpNum(p));
  PutLine('addrLod src [src]');
  PutLine('movR d'+a+a+' a [src]');
  q:=TempLabelNum;inc(TempLabelNum,3);
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  a:=GetStandardIntPrefix(b);
  PutLine('comp '+a+a+' a b');
  if (b[5]=#1) then b:='a' else b:='b';
  PutLine('jmpc '+b+' '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+3));
  CompileStatements('',q+3,q+2);
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
  PutOutProcAddr('src',GetNameProc(CurrProcNum),GetNameTmpNum(p+1));
  PutLine('movR d'+a+a+' b [src]');
  PutOutProcAddr('src',GetNameProc(CurrProcNum),GetNameTmpNum(p));
  PutLine('addrLod src [src]');
  PutLine('movR d'+a+a+' a [src]');
  if (b[5]=#1) then b:='add' else b:='sub';
  PutLine(b+' '+a[2]+' a 1');
  PutLine('movW d'+a+a+' [src] a');
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+3));
  dec(TempNumVarCur,2);
  goto f1;
  end;
if (a='if') then begin;
  ReadUpExpression(#13'then'#13,MemData1^,MemData2^);
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,3,0);
  if (copy(a,1,1)<>#3) then SignError('out of memory');
  delete(a,1,1);
  q:=TempLabelNum;inc(TempLabelNum,2);
  a:=NegateOneJumpCondition(a);
  b:=GetNextWord;
  if (kicsi(b)='else') then begin;
    a:=NegateOneJumpCondition(a);
    PutLine('jmpc '+a+' '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
    CompileStatements('',breakL,contnL);
    PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
    PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
    goto f1;
    end;
  PutBackWord(b);
  PutLine('jmpc '+a+' '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  CompileStatements('',breakL,contnL);
  b:=GetNextWord;
  if (kicsi(b)<>'else') then begin;
    PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
    PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
    PutBackWord(b);
    goto f1;
    end;
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  CompileStatements('',breakL,contnL);
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
  goto f1;
  end;
if (a='while') then begin;
  q:=TempLabelNum;inc(TempLabelNum,2);
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  ReadUpExpression(#13'do'#13,MemData1^,MemData2^);
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,3,0);
  if (copy(a,1,1)<>#3) then SignError('out of memory');
  delete(a,1,1);
  a:=NegateOneJumpCondition(a);
  PutLine('jmpc '+a+' '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
  CompileStatements('',q+2,q+1);
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
  goto f1;
  end;
if (a='repeat') then begin;
  q:=TempLabelNum;inc(TempLabelNum,3);
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  CompileStatements('until',q+3,q+2);
  PutBackWord(ReadUpExpression(StandardEndings,MemData1^,MemData2^));
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,3,0);
  if (copy(a,1,1)<>#3) then SignError('out of memory');
  delete(a,1,1);
  a:=NegateOneJumpCondition(a);
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+2));
  PutLine('jmpc '+a+' '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+1));
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(q+3));
  goto f1;
  end;
if (a='case') then begin;
  ReadUpExpression(#13'of'#13,MemData1^,MemData2^);
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,5,0);
  if (a[1]<>#5) then SignError('error in expression');
  str2bin(copy(a,2,255),o,sizeof(o));
  p:=TempLabelNum;inc(TempLabelNum);
  f3:
  SkipCommaBlock;
  b:=GetNextWord;
  a:=Kicsi(b);
  if (a='else') then begin;
    CompileStatements('',breakL,contnL);
    SkipCommaBlock;
    a:=kicsi(GetNextWord);
    if (a<>'end') then SignError('end expected');
    end;
  if (a='end') then begin;
    PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(p+1));
    goto f1;
    end;
  PutBackWord(b);
  ReadUpExpression(#13':'#13,MemData1^,MemData2^);
  a:=CodeOneCalc(MemData1^,MemData2^,MemData3^,6,o);
  if (a[1]<>#6) then SignError('error in expression');
  str2bin(copy(a,2,255),i,sizeof(i));
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(i+2));
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(i+1));
  CompileStatements('',breakL,contnL);
  PutLine('jump '+GetNameProc(CurrProcNum)+GetNameTmpLbl(p+1));
  PutLine('label '+GetNameProc(CurrProcNum)+GetNameTmpLbl(i+2));
  goto f3;
  end;
i:=0;
if (a='inc') then i:=1;
if (a='dec') then i:=2;
if (i<>0) then begin;
  if (GetNextword<>'(') then SignError('( expected');
  CodeOneEqualation(#1+chr(i),MemData1^,MemData2^,MemData3^);
  goto f1;
  end;
if (a=ending) then goto vege;

i:=GetStandardTypes(a);
if (i<>0) then begin;
  PutBackWord(a);
  CodeOneEqualation('',MemData1^,MemData2^,MemData3^);
  goto f1;
  end;
i:=MemoryFind(a,0,true,MemData1^);
if (i<0) then SignError('unknown identifier: '+a);
a:=MemoryGetName(MemData1^);
case ord(a[1]) of
  MemType_label:begin;
    if (GetNextWord<>':') then SignError(': expected');
    i:=FindOwnerProc(MemoryCurPos,true,MemData1^);
    a:=GetNameProc(i)+GetNameLabel(MemoryCurPos);
    PutLine('label '+a);
    goto f2;
    end;
  MemType_var:begin;
    delete(a,1,1);
    PutBackWord(a);
    CodeOneEqualation('',MemData1^,MemData2^,MemData3^);
    goto f1;
    end;
  MemType_type:begin;
    delete(a,1,1);
    PutBackWord(a);
    CodeOneEqualation('',MemData1^,MemData2^,MemData3^);
    goto f1;
    end;
  MemType_prcB:begin;
    delete(a,1,1);
    b:=GetNextWord;
    PutBackWord(b);
    if (b=':') then begin;
      a:=MemoryRec2str(MemData1^);
      str2bin(copy(a,2,255),i,sizeof(i));
      if (i<>CurrProcNum) then SignError('invalid procedure or function reference');
      a:=bin2str(CurrProcNum,sizeof(CurrProcNum))+Chr(CurrProcRet);
      CodeOneEqualation(#2+a,MemData1^,MemData2^,MemData3^);
      goto f1;
      end;
    PutBackWord(a);
    PutBackWord(ReadUpExpression(StandardEndings,MemData1^,MemData2^));
    CodeOneCalc(MemData1^,MemData2^,MemData3^,0,0);
    goto f1;
    end;
  end;
SignError('error in expression');
vege:
End;
