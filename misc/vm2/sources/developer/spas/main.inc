Procedure CompileOneFile(fn,plat:String);
Const
  OutCodeFile='.!1temp';
  OutDataFile='.!2temp';

Function ProcessVarDef(a:String;o:LongInt):LongInt;
Var
  i:LongInt;
  b:String;
Begin;
ProcessVarDef:=0;
delete(a,1,1);
PutLine(';'+a);
PutLine('const '+GetNameProc(CurrProcNum)+GetNameVar(MemoryCurPos)+' '+BStr(o));
b:=MemoryRec2str(MemData1^);
case ord(b[1]) of
  VarType_cnst:begin;
    PutOutProcAddr('trg',GetNameProc(CurrProcNum),GetNameVar(MemoryCurPos));
    str2bin(copy(b,2,255),MemoryCurPos,sizeof(MemoryCurPos));
    str2bin(copy(b,6,255),i,sizeof(i));
    PutLine('codeOfs src '+GetNameConst(i));
    if MemoryRead(MemData1^) then SignError('out of memory');
    MemoryGetName(MemData1^);
    MemData2^.s:=0;
    GetOffsetInType(MemData1^,MemData2^,MemData2^,i);
    a:='u'+DataSizesList[defOffsSize];
    PutLine('move '+a+a+' c '+BStr(i));
    PutLine('sysCall codeCopy');
    ProcessVarDef:=i;
    end;
  VarType_norm:begin;
    str2bin(copy(b,2,255),MemoryCurPos,sizeof(MemoryCurPos));
    if MemoryRead(MemData1^) then SignError('out of memory');
    MemoryGetName(MemData1^);
    MemData2^.s:=0;
    GetOffsetInType(MemData1^,MemData2^,MemData2^,i);
    ProcessVarDef:=i;
    end;
  VarType_tptr:begin;
    ProcessVarDef:=defAddrSize;
    end;
  VarType_absl:begin;
    PutOutProcAddr('trg',GetNameProc(CurrProcNum),GetNameVar(MemoryCurPos));
    str2bin(copy(b,6,255),i,sizeof(i));
    o:=FindOwnerProc(i,true,MemData1^);
    PutOutProcAddr('src',GetNameProc(o),GetNameVar(i));
    MemoryCurPos:=i;
    if MemoryRead(MemData1^) then SignError('out of memory');
    MemoryGetName(MemData1^);
    a:=MemoryRec2str(MemData1^);
    i:=ord(a[1]);
    if (i in [VarType_absl,VarType_pflt,VarType_punt]) then PutLine('addrLod src [src]');
    str2bin(copy(b,10,255),i,sizeof(i));
    if (i<>0) then PutLine('add '+DataSizesList[defOffsSize]+' src '+BStr(i));
    PutLine('addrSav [trg] src');
    ProcessVarDef:=defAddrSize;
    end;
  VarType_pnrm:begin;
    str2bin(copy(b,2,255),MemoryCurPos,sizeof(MemoryCurPos));
    if MemoryRead(MemData1^) then SignError('out of memory');
    MemoryGetName(MemData1^);
    MemData2^.s:=0;
    GetOffsetInType(MemData1^,MemData2^,MemData2^,i);
    ProcessVarDef:=i;
    end;
  VarType_pflt:begin;
    ProcessVarDef:=defAddrSize;
    end;
  VarType_punt:begin;
    ProcessVarDef:=defAddrSize;
    end;
  else SignError('out of memory');
  end;
End;

Procedure WriteOutPosition(n:LongInt);
Begin;
Write(#13'(');
Write(Copy(BStr(n)+'      ',1,6));
Write(')'#13);
End;

Function GetOneUserNumber(a:String):LongInt;
Var
  n,m:LongInt;
  c:Char;
Begin;
a:=kicsi(a);
m:=1;
c:=a[length(a)];
if (c='k') then m:=1024;
if (c='m') then m:=1024*1024;
if (m<>1) then a:=copy(a,1,length(a)-1);
n:=BVal(a);
GetOneUserNumber:=m*n;
End;

Label f1,f2,f3,f4,f5,f6;
Label f7,f8,f9,f10;
Label f12,f13,f14,f15;
Var
  prgName:String;
  prgStack:LongInt;
  prgData:LongInt;
  mode:byte; {0=none, 1=const, 2=type, 3=var}
  a,b,c:String;
  i,o,p:LongInt;
Begin;
TemporaryPath:=xFileName(fn,1)+xFileName(fn,2);
AllFileHndPos:=0;
UnNeededWord:='';
UnNeededChar:='';
MemoryCurSize:=0;
MemoryCurPos:=0;
mode:=0;
TempStrVarMax:=0;
TempStrVarCur:=0;
TempNumVarMax:=0;
TempNumVarCur:=0;
TempLabelNum:=0;
NumberConst:=0;
NumberProc:=0;
CurrProcPos:=0;
CurrProcNum:=0;
CurrProcRet:=0;
DefinitionsList:=#13'spas'#13;
prgStack:=defStckSize;
prgData:=defHeapSize;
prgName:='';
WriteLn('Compiling '+fn+'...');
if OpenOneFile(fn) then SignError('file not found: '+fn);

xtReWrite(OutCodeHandler,GetTemporaryName(OutCodeFile));
xtReWrite(OutDataHandler,GetTemporaryName(OutDataFile));

b:=GetNextWord;a:=kicsi(b);
if (a='program') or (a='unit') then begin;
  prgName:=GetNextWord;
  b:=GetNextWord;
  if (b<>';') then SignError('; expected');
  if (a='unit') then SignError('unit not yet supported!');
  end else PutBackWord(b);
f1:
ExpressionBegin:=CurrentFileLin;
b:=GetNextWord;a:=kicsi(b);
if (a='') then begin;
  if CloseCurrFile then SignError('unexpected end of file in declaration part');
  mode:=0;
  goto f1;
  end;
if (a='uses') then SignError('uses not yet supported!');
if (a='const') then begin; mode:=1;goto f1; end;
if (a='type') then begin; mode:=2;goto f1; end;
if (a='var') then begin; mode:=3;goto f1; end;
if (a='label') then begin;
  repeat
    b:=GetNextWord;
    TestOneIdentifier(b);
    o:=MemoryFind(b,0,false,MemData1^);
    if (o>-1) then SignError('duplicate identifier: '+b);
    MemData1^.s:=0;
    MemoryPut2end(b,MemType_label,MemData1^);
    a:=GetNextWord;
    until (a=';');
  mode:=0;
  goto f1;
  end;
if (copy(a,1,1)='{') then begin;
  UnpackDirectives(a,b);
  if (a='$sysinc') then begin;
    b:=UsrLibraryPath+b;
    a:='$include';
    end;
  if (a='$include') then begin;
    a:=AllFileHndDat[AllFileHndPos].fn;
    if (copy(b,2,1)<>':') and (copy(b,1,1)<>'\') then begin;
      i:=posL('\',a);
      b:=copy(a,1,i)+b;
      end;
    if OpenOneFile(b) then SignError('file not found: '+b);
    mode:=0;
    ClrEol;
    goto f1;
    end;
  if (a='$stack') then begin;
    prgStack:=GetOneUserNumber(b);
    goto f1;
    end;
  if (a='$heap') then begin;
    prgData:=GetOneUserNumber(b);
    goto f1;
    end;
  if ProcessDefinitions(a,b) then goto f1;
  goto f1;
  end;
p:=0;
if (a='procedure') then p:=1;
if (a='function') then p:=2;
if (p<>0) then begin;
  b:=GetNextWord;
  TestOneIdentifier(b);
  o:=MemoryFind(b,0,false,MemData1^);
  if (o>-1) then SignError('duplicate identifier: '+b);
  inc(NumberProc);
  a:=bin2str(CurrProcNum,sizeof(CurrProcNum))+bin2str(CurrProcPos,sizeof(CurrProcPos));
  CurrProcNum:=NumberProc;
  a:=chr(p)+bin2str(CurrProcNum,sizeof(CurrProcNum))+a;
  MemoryStr2rec(MemData1^,a);
  MemoryPut2end(b,MemType_prcB,MemData1^);
  CurrProcPos:=MemoryCurSize;
  a:=GetNextWord;
  if (a<>'(') then begin; PutBackWord(a);goto f3; end;
  f4:
  b:='';p:=VarType_pnrm;
  a:=GetNextWord;
  if (kicsi(a)='var') then p:=VarType_pflt else PutBackWord(a);
  repeat
    a:=GetNextWord;
    TestOneIdentifier(a);
    i:=MemoryFind(a,0,false,MemData1^);
    if (i>-1) then SignError('duplicate identifier: '+a);
    b:=b+a+#13;
    a:=GetNextWord;
    if (a<>':') and (a<>';') and (a<>')') and (a<>',') then SignError(': expected');
    until (a=':') or (a=';') or (a=')');
  if (Length(b)>250) then SignError('parameter identifier list too long');
  c:='';
  if (a<>':') then begin;
    PutBackWord(a);
    p:=VarType_punt;
    i:=-1;
    goto f5;
    end;
  a:=GetNextWord;
  i:=MemoryFind(a,MemType_type,true,MemData1^);
  if (i<0) then begin;
    PutBackWord(a);
    ReadUpTypeDef(MemData1^,MemData2^);
    i:=MemoryCurSize;
    MemoryPut2end('',MemType_type,MemData1^);
    end;
  f5:
  c:=chr(p)+bin2str(i,sizeof(i));
  while (b<>'') do begin;
    i:=pos(#13,b);
    a:=copy(b,1,i-1);
    delete(b,1,i);
    MemoryStr2rec(MemData1^,c);
    MemoryPut2end(a,MemType_var,MemData1^);
    end;
  a:=GetNextWord;
  if (a=';') then goto f4;
  if (a<>')') then SignError(') expected');
  f3:
  MemoryCurPos:=CurrProcPos;
  if MemoryBack then SignError('out of memory');
  if MemoryRead(MemData1^) then SignError('out of memory');
  c:=MemoryGetName(MemData1^);p:=0;
  delete(c,1,1);
  i:=ord(MemData1^.d[1]);
  if (i=2) then begin;
    a:=GetNextWord;
    if (a<>':') then SignError(': expected');
    a:=GetNextWord;
    p:=GetStandardTypes(a);
    if (p<=0) then SignError('invalid function result type');
    end else p:=0;
  a:=GetNextWord;
  if (a<>';') then SignError('; expected');
  a:=bin2str(p,sizeof(p));
  MemoryStr2rec(MemData1^,a);
  MemoryPut2end('',MemType_prcE,MemData1^);
  mode:=0;
  goto f1;
  end;
if (a='begin') then goto f6;
case mode of
  3:begin; {var}
    PutBackWord(b);
    b:='';
    repeat
      a:=GetNextWord;
      TestOneIdentifier(a);
      i:=MemoryFind(a,0,false,MemData1^);
      if (i>-1) then SignError('duplicate identifier: '+a);
      b:=b+a+#13;
      a:=GetNextWord;
      if (a<>':') and (a<>',') then SignError(': expected');
      until (a=':');
    if (Length(b)>250) then SignError('variable identifier list too long');
    p:=VarType_norm;
    a:=GetNextWord;
    if (a='^') then begin; p:=VarType_tptr;a:=GetNextWord; end;
    o:=MemoryFind(a,MemType_type,true,MemData1^);
    if (o<0) then begin;
      PutBackWord(a);
      ReadUpTypeDef(MemData1^,MemData2^);
      o:=MemoryCurSize;
      MemoryPut2end('',MemType_type,MemData1^);
      end;
    MemoryGetName(MemData1^);
    c:=bin2str(o,sizeof(o));
    a:=kicsi(GetNextWord);
    if (a=';') then goto f2;
    if (a<>'absolute') then SignError('; expected');
    if (p<>VarType_norm) then SignError('; expected');
    a:=GetNextWord;
    o:=MemoryFind(a,MemType_var,true,MemData1^);
    if (o<0) then SignError('variable identifier expected');
    c:=c+bin2str(o,sizeof(o));
    MemoryGetName(MemData1^);
    a:=MemoryRec2str(MemData1^);
    i:=ord(a[1]);
    if (i in [VarType_cnst,VarType_norm,VarType_absl,VarType_pnrm,VarType_pflt]) then begin;
      str2bin(copy(a,2,255),MemoryCurPos,sizeof(MemoryCurPos));
      if MemoryRead(MemData1^) then SignError('out of memory');
      MemoryGetName(MemData1^);
      PutBackWord(ReadUpExpression(#13';'#13,MemData3^,MemData2^));
      GetOffsetInType(MemData1^,MemData2^,MemData3^,p);
      if (MemData3^.s<>0) then SignError('error in expression');
      a:=EvaluateConstant(MemData2^);
      if (copy(a,1,1)<>#1) then SignError('integer expression expected');
      delete(a,1,1);
      str2bin(a,p,sizeof(p));
      end else p:=0;
    if (GetNextWord<>';') then SignError('; expected');
    c:=c+bin2str(p,sizeof(p));
    p:=VarType_absl;
    f2:
    c:=chr(p)+c;
    while (b<>'') do begin;
      i:=pos(#13,b);
      a:=copy(b,1,i-1);
      delete(b,1,i);
      MemoryStr2rec(MemData1^,c);
      MemoryPut2end(a,MemType_var,MemData1^);
      end;
    goto f1;
    end;
  2:begin; {type}
    TestOneIdentifier(b);
    o:=MemoryFind(b,0,false,MemData1^);
    if (o>-1) then SignError('duplicate identifier: '+b);
    a:=GetNextWord;
    if (a<>'=') then SignError('= expected');
    ReadUpTypeDef(MemData1^,MemData2^);
    a:=GetNextWord;
    if (a<>';') then SignError('; expected');
    MemoryPut2end(b,MemType_type,MemData1^);
    goto f1;
    end;
  1:begin; {const}
    TestOneIdentifier(b);
    o:=MemoryFind(b,0,false,MemData1^);
    if (o>-1) then SignError('duplicate identifier: '+b);
    a:=GetNextWord;
    if (a='=') then begin;
      ReadUpExpression(#13';'#13,MemData1^,MemData2^);
      a:=EvaluateConstant(MemData1^);
      if (a='') then SignError('error in expression');
      MemoryStr2rec(MemData1^,a);
      MemoryPut2end(b,MemType_cnst,MemData1^);
      goto f1;
      end;
    if (a<>':') then SignError(': expected');
    a:=GetNextWord;
    o:=MemoryFind(a,MemType_type,true,MemData1^);
    if (o<0) then begin;
      PutBackWord(a);
      ReadUpTypeDef(MemData1^,MemData2^);
      o:=MemoryCurSize;
      MemoryPut2end('',MemType_type,MemData1^);
      end;
    MemoryGetName(MemData1^);i:=o;
    a:=GetNextWord;
    if (a<>'=') then SignError('= expected');
    o:=CurrProcNum;
    move(o,MemData2^.d[5],sizeof(o));
    inc(NumberConst);o:=NumberConst;
    move(o,MemData2^.d[1],sizeof(o));
    ReadUpTypedConst(MemData1^,MemData2^);
    a:=GetNextWord;
    if (a<>';') then SignError('; expected');
    o:=NumberConst;
    a:=chr(VarType_cnst)+bin2str(i,sizeof(i))+bin2str(o,sizeof(o));
    MemoryStr2rec(MemData1^,a);
    MemoryPut2end(b,MemType_var,MemData1^);
    goto f1;
    end;
  end;
SignError('begin expected');

f6:
MemoryCurPos:=CurrProcPos;
CurrProcRet:=0;
if (CurrProcNum<>0) then begin;
  if MemoryBack then SignError('out of memory');
  if MemoryRead(MemData1^) then SignError('out of memory');
  if MemoryNext then SignError('out of memory');
  a:=MemoryGetName(MemData1^);
  end else a:='%%%% MAiN %%%';
PutType(MemType_prcB);
b:=GetNameProc(CurrProcNum);
PutLine(';'+copy(a,2,255)+' - '+BStr(CurrProcNum));
PutLine('proc '+b);
if (CurrProcNum=0) then begin;
  PutLine('syscall startup');
  PutLine('procAllocBeg '+b+'ds '+b+'vars');
  PutLine('procAllocEnd '+b+'ds '+b+'vars');
  end;
o:=0;
repeat
  p:=0;
  if MemoryRead(MemData1^) then inc(p);
  a:=MemoryGetName(MemData1^);
  if (copy(a,1,1)=chr(MemType_prcE)) then begin;
    b:=MemoryRec2str(MemData1^);
    str2bin(b,CurrProcRet,sizeof(CurrProcRet));
    end;
  if (copy(a,1,1)=chr(MemType_prcB)) then repeat
    if MemoryNext then SignError('out of memory');
    if MemoryRead(MemData1^) then SignError('out of memory');
    a:=MemoryGetName(MemData1^);
    until (copy(a,1,1)=chr(MemType_prcE));
  i:=MemoryCurPos;
  if (copy(a,1,1)=chr(MemType_var)) then inc(o,ProcessVarDef(a,o));
  alignOneNumber(o);
  MemoryCurPos:=i;
  if MemoryNext then inc(p);
  until (p<>0);
p:=o;
if (CurrProcRet<>0) then begin;
  PutLine('const '+GetNameProc(CurrProcNum)+'res '+BStr(p));
  a:=chr(CurrProcRet)+#0#0#0;
  i:=GetStandardTypeLen(a);
  inc(p,i);
  end;
alignOneNumber(p);
TempStrVarMax:=0;TempStrVarCur:=0;
TempNumVarMax:=0;TempNumVarCur:=0;
TempLabelNum:=0;
PutLine(';statement block begins here...');
CompileStatements('end',-1,-1);
PutLine(';statement block ends here...');
a:=GetNameProc(CurrProcNum);
PutLine('label '+a+'end');
if (CurrProcRet<>0) then PutOutProcAddr('src',a,'res');
if (CurrProcNum<>0) then PutLine('ret') else begin;
  PutLine('procFree '+a+'ds '+a+'vars');
  PutLine('sub w a a');
  PutLine('sysCall terminate');
  end;
o:=GetStandardTypeLen(chr(DatType_strg)+#0#0#0);
for i:=1 to TempStrVarMax do begin;
  PutLine('const '+GetNameProc(CurrProcNum)+GetNameTmpStr(i)+' '+BStr(p));
  inc(p,o);
  alignOneNumber(p);
  end;
o:=defMxItSize;if (o<defAddrSize) then o:=defAddrSize;
for i:=1 to TempNumVarMax do begin;
  PutLine('const '+GetNameProc(CurrProcNum)+GetNameTmpNum(i)+' '+BStr(p));
  inc(p,o);
  alignOneNumber(p);
  end;
PutLine('const '+GetNameProc(CurrProcNum)+'vars '+BStr(p));
PutLine('endp');
PutType(MemType_prcE);
PutLine('');
a:=GetNextWord;
if (CurrProcNum<>0) then begin;
  if (a<>';') then SignError('; expected');
  MemoryCurPos:=CurrProcPos;
  if MemoryBack then SignError('out of memory');
  if MemoryRead(MemData1^) then SignError('out of memory');
  if (MemData1^.d[1]<>chr(MemType_prcB)) then SignError('out of memory');
  MemoryGetName(MemData1^);
  a:=MemoryRec2str(MemData1^);
  delete(a,1,5);
  str2bin(a,CurrProcNum,sizeof(CurrProcNum));delete(a,1,sizeof(CurrProcNum));
  str2bin(a,CurrProcPos,sizeof(CurrProcPos));delete(a,1,sizeof(CurrProcPos));
  repeat
    if MemoryRead(MemData1^) then SignError('out of memory');
    if MemoryNext then SignError('out of memory');
    a:=MemoryGetName(MemData1^);
    until (copy(a,1,1)=chr(MemType_prcE));
  MemoryCurSize:=MemoryCurPos;
  MemoryStr2rec(MemData1^,'');
  MemoryPut2end('',MemType_prcC,MemData1^);
  mode:=0;
  goto f1;
  end;
if (a<>'.') then SignError('. expected');
repeat until CloseCurrFile;

xtClose(OutDataHandler);
xtClose(OutCodeHandler);

ClrEol;WriteLn('Scanning proc usage...');
if xtOpen(OutDataHandler,GetTemporaryName(OutCodeFile),true)<>0 then SignError('out of memory');
CurrProcPos:=0;
CurrProcNum:=0;
MemoryCurSize:=0;
MemoryCurPos:=0;
NumberProc:=0;
f7:
if FindOneTypeInSource(OutDataHandler,MemType_prcB) then goto f8;
a:=xtReadLn(OutDataHandler,255);
CurrProcNum:=GetPrcNmFromAsmLine(a);
if (CurrProcNum>NumberProc) then NumberProc:=CurrProcNum;
MemData1^.s:=0;
MemoryPut2end(BStr(CurrProcNum),MemType_prcB,MemData1^);
CurrProcPos:=MemoryCurSize;
WriteOutPosition(CurrProcNum);
repeat
  a:=xtReadLn(OutDataHandler,255);
  i:=GetTypeFromAsmLine(a);
  if (i=MemType_prcC) then begin;
    a:=xtReadLn(OutDataHandler,255);
    o:=GetPrcNmFromAsmLine(a);
    a:=BStr(o);
    if (o=0) then SignError('out of memory');
    o:=MemoryFind(a,MemType_prcC,false,MemData2^);
    if (o<0) then begin;
      MemData1^.s:=0;
      MemoryPut2end(a,MemType_prcC,MemData1^);
      end;
    end;
  until (i=MemType_prcE);
MemData1^.s:=0;
MemoryPut2end(BStr(CurrProcNum),MemType_prcE,MemData1^);
goto f7;
f8:
FillChar(MemData3^,sizeof(MemData3^),0);
if (NumberProc>sizeof(MemData3^.d)) then SignError('too many calls');
MemoryCurPos:=MemoryCurSize;
f9:
if MemoryBack then goto f10;
if MemoryRead(MemData1^) then SignError('out of memory');
a:=MemoryGetName(MemData1^);
i:=ord(a[1]);
delete(a,1,1);
o:=BVal(a);
if (BStr(o)<>a) then SignError('out of memory');
if (o>NumberProc) then SignError('out of memory');
case i of
  MemType_prcB:WriteOutPosition(o);
  MemType_prcE:begin;
    if (o=0) then goto f9;
    if (MemData3^.d[o]<>#0) then goto f9;
    repeat
      if MemoryBack then SignError('out of memory');
      if MemoryRead(MemData1^) then SignError('out of memory');
      a:=MemoryGetName(MemData1^);
      until (copy(a,1,1)=chr(MemType_prcB));
    end;
  MemType_prcC:MemData3^.d[o]:=#1;
  else SignError('out of memory');
  end;
goto f9;
f10:
ClrEol;WriteLn('Creating output...');
a:=xFileName(fn,1)+xFileName(fn,2)+'.vma';
xtReWrite(OutCodeHandler,a);
a:=DataSizesList[defIntgSize];
PutLine('platform '+plat);
PutLine('');
PutLine('');
PutLine(';--------------------------------------');
PutLine('proc StringCopy');
PutLine(';in: trg-where to add...');
PutLine(';    src-string to add...');
PutLine(';    '+a+':c-max size of block...');
PutLine('movr du'+a+'ub a [src]');
PutLine('comp u'+a+'u'+a+' c a');
PutLine('jmpc na StringCopy_j1');
PutLine('move u'+a+'u'+a+' c a');
PutLine('label StringCopy_j1');
PutLine('movw dubub [trg] c');
PutLine('add '+a+' src 1');
PutLine('add '+a+' trg 1');
PutLine('syscall memcopy');
PutLine('ret');
PutLine('endp');
PutLine(';--------------------------------------');
PutLine('proc StringAppendStr');
PutLine(';in: trg-where to add...');
PutLine(';    src-string to add...');
PutLine('move u'+a+'u'+a+' c 255');
PutLine('movr du'+a+'ub a [trg]');
PutLine('movr du'+a+'ub b [src]');
PutLine('move u'+a+'u'+a+' d a');
PutLine('sub '+a+' c a');
PutLine('comp u'+a+'u'+a+' c b');
PutLine('jmpc na StringAppendStr_j1');
PutLine('move u'+a+'u'+a+' c b');
PutLine('label StringAppendStr_j1');
PutLine('add '+a+' a c');
PutLine('movw dubub [trg] a');
PutLine('add '+a+' trg d');
PutLine('add '+a+' src 1');
PutLine('add '+a+' trg 1');
PutLine('syscall memcopy');
PutLine('ret');
PutLine('endp');
PutLine(';--------------------------------------');
PutLine('proc StringAppendChr');
PutLine(';in: trg-where to add...');
PutLine(';    b:a-char to append...');
PutLine('movr du'+a+'ub b [trg]');
PutLine('comp u'+a+'s'+a+' b 255');
PutLine('jmpc ae StringAppendChr_j1');
PutLine('add '+a+' b 1');
PutLine('movw dubub [trg] b');
PutLine('add '+a+' trg b');
PutLine('movw dubub [trg] a');
PutLine('label StringAppendChr_j1');
PutLine('ret');
PutLine('endp');
PutLine(';--------------------------------------');
PutLine('proc StringCompare');
PutLine(';in:  src-string one...');
PutLine(';     trg-string two...');
PutLine(';out: a,b seted for unsigned compare...');
PutLine('movr du'+a+'ub c [src]');
PutLine('movr du'+a+'ub d [trg]');
PutLine('label StringCompare_j1');
PutLine('add '+a+' trg 1');
PutLine('add '+a+' src 1');
PutLine('comp u'+a+'u'+a+' c 1');
PutLine('jmpc b StringCompare_j2');
PutLine('comp u'+a+'u'+a+' d 1');
PutLine('jmpc b StringCompare_j2');
PutLine('sub '+a+' c 1');
PutLine('sub '+a+' d 1');
PutLine('movr dubub b [src]');
PutLine('movr dubub a [trg]');
PutLine('comp ubub a b');
PutLine('jmpc ne StringCompare_j3');
PutLine('jump StringCompare_j1');
PutLine('label StringCompare_j2');
PutLine('move ubub b c');
PutLine('move ubub a d');
PutLine('label StringCompare_j3');
PutLine('ret');
PutLine('endp');
PutLine(';--------------------------------------');
PutLine('');
PutLine('');
PutLine('');
PutLine('const '+GetNameProc(0)+'ds 0');
o:=0;
for i:=1 to MemoryMaxRecord do if (MemData3^.d[i]<>#0) then begin;
  inc(o);
  PutLine('const '+GetNameProc(i)+'ds '+BStr(o));
  end;
PutLine('');
PutLine('');

xtSetPos(OutDataHandler,0);
f12:
if FindOneTypeInSource(OutDataHandler,MemType_prcB) then goto f13;
a:=xtReadLn(OutDataHandler,255);
i:=GetPrcNmFromAsmLine(a);
WriteOutPosition(i);
if (i>0) and (MemData3^.d[i]=#0) then begin;
  if FindOneTypeInSource(OutDataHandler,MemType_prcE) then SignError('out of memory');
  goto f12;
  end;
repeat
  if (a='syscall startup') then begin;
    o:=1;
    for i:=1 to MemoryMaxRecord do if (MemData3^.d[i]<>#0) then inc(o);
    a:='sysCall startUp '+BStr(o)+' '+BStr(prgStack)+' '+BStr(prgData);
    end;
  PutLine(a);
  if xtEOF(OutDataHandler) then SignError('out of memory');
  a:=xtReadLn(OutDataHandler,255);
  i:=GetTypeFromAsmLine(a);
  until (i=MemType_prcE);
PutLine('');
goto f12;
f13:
xtClose(OutDataHandler);
if xtOpen(OutDataHandler,GetTemporaryName(OutDataFile),true)<>0 then SignError('out of memory');
PutLine('');
PutLine('');
f14:
if FindOneTypeInSource(OutDataHandler,MemType_prcB) then goto f15;
a:=xtReadLn(OutDataHandler,255);
i:=GetPrcNmFromAsmLine(a);
WriteOutPosition(i);
if (i>0) and (MemData3^.d[i]=#0) then begin;
  if FindOneTypeInSource(OutDataHandler,MemType_prcE) then SignError('out of memory');
  goto f14;
  end;
repeat
  PutLine(a);
  if xtEOF(OutDataHandler) then SignError('out of memory');
  a:=xtReadLn(OutDataHandler,255);
  i:=GetTypeFromAsmLine(a);
  until (i=MemType_prcE);
PutLine('');
goto f14;
f15:
xtClose(OutDataHandler);
xtClose(OutCodeHandler);
a:=xtReadLn(OutDataHandler,255);
i:=GetPrcNmFromAsmLine(a);
WriteOutPosition(i);

xErase(GetTemporaryName(OutCodeFile));
xErase(GetTemporaryName(OutDataFile));

ClrEol;WriteLn('Successfully finished!');
End;
