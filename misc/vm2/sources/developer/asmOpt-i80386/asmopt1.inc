Const
  StackMaximum=16;
  MemoryMaximum=16;
Var
  UnknownDataCounter:LongInt;
  OpCode:Array[0..6] of String;
  RegistersDatL:Array[0..7] of record a:String;l:LongInt; end;
  RegistersDatX:Array[0..8] of record a:String;l:LongInt; end;
  RegistersDatE:Array[0..8] of record a:String;l:LongInt; end;
  RegistersSeg:Array[0..5] of record a:String;l:LongInt; end;
  StackValues:Array[1..StackMaximum] of record a:String;l:LongInt; end;
  StackPointer:ShortInt;
  MemoryValues:Array[1..MemoryMaximum] of record n:string;v:String;l:LongInt; end;
  MemoryPointer:Byte;


Function GetInvData:String;
Begin;
UnknownDataCounter:=(UnknownDataCounter+1) and $fffffff;
GetInvData:='#i'+BStr(UnknownDataCounter)+'#';
End;


Function OneValueRead(n:String;exp:boolean):String;
Label vege;
Var
  i:LongInt;
  a,b,c:String;
Begin;
i:=-1;
if (n='eax') then i:=0;
if (n='ebx') then i:=1;
if (n='ecx') then i:=2;
if (n='edx') then i:=3;
if (n='esi') then i:=4;
if (n='edi') then i:=5;
if (n='ebp') then i:=6;
if (n='esp') then i:=7;
if (n='eflag') then i:=8;
if (i>=0) then begin;
  a:=RegistersDatE[i].a;
  b:=RegistersDatX[i].a;
  if (b<>'') then a:=a+'~'+b;
  if (i<4) then begin;
    b:=RegistersDatL[i+0].a;
    if (b<>'') then a:=a+'~'+b;
    b:=RegistersDatL[i+4].a;
    if (b<>'') then a:=a+'~'+b;
    end;
  goto vege;
  end;
i:=-1;
if (n='ax') then i:=0;
if (n='bx') then i:=1;
if (n='cx') then i:=2;
if (n='dx') then i:=3;
if (n='si') then i:=4;
if (n='di') then i:=5;
if (n='bp') then i:=6;
if (n='sp') then i:=7;
if (n='flag') then i:=8;
if (i>=0) then begin;
  if (i<4) then begin;
    a:=RegistersDatL[i+0].a;
    b:=RegistersDatL[i+4].a;
    end else begin; a:='';b:=''; end;
  c:=RegistersDatX[i].a;
  if (c='') then c:='lo~'+RegistersDatE[i].a;
  if (a+b='') then begin; a:=c;goto vege; end;
  if (a='') then a:='lo~'+c;
  if (b='') then b:='hi~'+c;
  a:='~'+a+'~'+b;
  goto vege;
  end;
i:=-1;
if (n='al') then i:=0;
if (n='bl') then i:=1;
if (n='cl') then i:=2;
if (n='dl') then i:=3;
if (n='ah') then i:=4;
if (n='bh') then i:=5;
if (n='ch') then i:=6;
if (n='dh') then i:=7;
if (i>=0) then begin;
  a:=RegistersDatL[i].a;
  if (a<>'') then goto vege;
  if (i<4) then a:='~lo~' else a:='~hi~';
  i:=i and 3;
  b:=RegistersDatX[i].a;
  a:=a+b;
  if (b<>'') then goto vege;
  a:=a+'lo~'+RegistersDatE[i].a;
  goto vege;
  end;
i:=-1;
if (n='ds') then i:=0;
if (n='es') then i:=1;
if (n='ss') then i:=2;
if (n='cs') then i:=3;
if (n='fs') then i:=4;
if (n='gs') then i:=5;
if (i>=0) then begin;
  a:=RegistersSeg[i].a;
  goto vege;
  end;
if not exp then begin; a:='';goto vege; end;
if (pos(':',n)=0) then begin; a:='%v%'+n;goto vege; end;
for i:=1 to MemoryMaximum do if (MemoryValues[i].n=n) then begin;
  a:=MemoryValues[i].v;
  goto vege;
  end;
a:=GetInvData;
inc(MemoryPointer);
if (MemoryPointer>MemoryMaximum) then MemoryPointer:=1;
MemoryValues[MemoryPointer].n:=n;
MemoryValues[MemoryPointer].v:=a;
MemoryValues[MemoryPointer].l:=0;
vege:
if (a='') then a:=GetInvData;
OneValueRead:=a;
End;

Procedure OneValueWrite(n,d:String;l:LongInt);
Var i:LongInt;
Begin;
if (d='') then d:=GetInvData;
i:=-1;
if (n='eax') then i:=0;
if (n='ebx') then i:=1;
if (n='ecx') then i:=2;
if (n='edx') then i:=3;
if (n='esi') then i:=4;
if (n='edi') then i:=5;
if (n='ebp') then i:=6;
if (n='esp') then i:=7;
if (n='eflag') then i:=8;
if (i>=0) then begin;
  RegistersDatE[i].a:=d;
  RegistersDatE[i].l:=l;
  RegistersDatX[i].a:='';
  RegistersDatX[i].l:=0;
  if (i<4) then begin;
    RegistersDatL[i+0].a:='';
    RegistersDatL[i+4].a:='';
    RegistersDatL[i+0].l:=0;
    RegistersDatL[i+4].l:=0;
    end;
  exit;
  end;
i:=-1;
if (n='ax') then i:=0;
if (n='bx') then i:=1;
if (n='cx') then i:=2;
if (n='dx') then i:=3;
if (n='si') then i:=4;
if (n='di') then i:=5;
if (n='bp') then i:=6;
if (n='sp') then i:=7;
if (n='flag') then i:=8;
if (i>=0) then begin;
  RegistersDatX[i].a:=d;
  RegistersDatX[i].l:=l;
  if (i<4) then begin;
    RegistersDatL[i+0].a:='';
    RegistersDatL[i+4].a:='';
    RegistersDatL[i+0].l:=0;
    RegistersDatL[i+4].l:=0;
    end;
  exit;
  end;
i:=-1;
if (n='al') then i:=0;
if (n='bl') then i:=1;
if (n='cl') then i:=2;
if (n='dl') then i:=3;
if (n='ah') then i:=4;
if (n='bh') then i:=5;
if (n='ch') then i:=6;
if (n='dh') then i:=7;
if (i>=0) then begin;
  RegistersDatL[i].a:=d;
  RegistersDatL[i].l:=l;
  exit;
  end;
i:=-1;
if (n='ds') then i:=0;
if (n='es') then i:=1;
if (n='ss') then i:=2;
if (n='cs') then i:=3;
if (n='fs') then i:=4;
if (n='gs') then i:=5;
if (i>=0) then begin;
  RegistersSeg[i].a:=d;
  RegistersSeg[i].l:=l;
  exit;
  end;
for i:=1 to MemoryMaximum do if (MemoryValues[i].n=n) then begin;
  MemoryValues[i].v:=d;
  MemoryValues[i].l:=l;
  exit;
  end;
inc(MemoryPointer);
if (MemoryPointer>MemoryMaximum) then MemoryPointer:=1;
MemoryValues[MemoryPointer].n:=n;
MemoryValues[MemoryPointer].v:=d;
MemoryValues[MemoryPointer].l:=l;
End;



Function StackDataPopOne:String;
Begin;
if (StackPointer<1) then begin;
  StackDataPopOne:=GetInvData;
  Exit;
  end;
StackDataPopOne:=StackValues[StackPointer].a;
dec(StackPointer);
End;

Procedure StackDataPushOne(a:String;l:LongInt);
Var i:Word;
Begin;
inc(StackPointer);
if (StackPointer>StackMaximum) then begin;
  StackPointer:=StackMaximum;
  for i:=1 to StackMaximum-1 do StackValues[i]:=StackValues[i+1];
  end;
StackValues[StackPointer].a:=a;
StackValues[StackPointer].l:=l;
End;






Procedure FelbontOpcode(a:String);
Label f1;
Var i,p:LongInt;
Begin;
fillchar(opcode,sizeof(opcode),0);
if (a='') then exit;
if (a[1]=';') then exit;
i:=pos(' ',a);
if (i=0) then i:=$666;
opcode[0]:=xLevesz(copy(a,1,i-1));
delete(a,1,i);
if IsThisBeg(a,'byte') or IsThisBeg(a,'word') or IsThisBeg(a,'dword')
 or IsThisBeg(a,'short') or IsThisBeg(a,'near') or IsThisBeg(a,'far') then begin;
  i:=pos(' ',a);
  if (i=0) then i:=$666;
  delete(a,1,i);
  end;
for p:=1 to 5 do begin;
  f1:
  i:=pos(',',a);
  if (i=0) then i:=$666;
  opcode[p]:=xLevesz(copy(a,1,i-1));
  delete(a,1,i);
  end;
opcode[6]:=xLevesz(a);
End;

Procedure KijavitMemParams;
Label f1;
Var
  i,o:LongInt;
  a,b,c:String;

procedure x(z:string);
begin;
if (pos(z,b)=0) then exit;
kicserel(z,OneValueRead(z,false),b);
end;

Begin;
for o:=1 to 6 do begin;
  a:=OpCode[o];
  i:=pos(':',a);
  if (i=0) then goto f1;
  b:=xLevesz(copy(a,i+1,255));
  a:=xLevesz(copy(a,1,i-1));
  x('eax');x('ebx');x('ecx');x('edx');
  x('esi');x('edi');x('esp');x('ebp');
  x('ax');x('bx');x('cx');x('dx');
  x('si');x('di');x('sp');x('bp');
  if (a='def') then begin;
    i:=pos('bp',b);
    if (i=0) then a:='ds' else a:='ss';
    end;
  c:=OneValueRead(a,false);
  if (c='') then goto f1;
  OpCode[o]:=c+':'+b;
  f1:
  end;
End;
