in this script language, every line has the following structure:
<command> [parameter#1] [parameter#2] ... [parameter#N]  [;comment]
each parameters and the command are strings...

the parameter given to the script, will be in the
readed variable after startup...

 strings
~~~~~~~~~
there is two way to give a string:
1) if it does not contains space, then simply write it down...
2) if it contains space(s), then enclose with two " character...
in both case, the escaping rules apply to the string:
- string is scanned for ^ character... the next character after
  it is truncated to 5 bits... example: if you would place
  an enter in the string, you can do by typing "^M"...
string is scanned for \ character... this is the real escape
character in this language; it has a lot of cases, only one of
them apply for one escape sequence:
- the next is \ char: a single \ is placed...
- the next is ^ char: a single ^ is placed...
- the next is @ char: a single " is placed...
- the next is _ char: a single space is placed...
- the next is number and \: the ascii code is placed...
- the next is result\ string: result code; 0=ok, 1=error, 2=ring, 3=connect...
- the next is goodRes\ string: 1 if not error, else 0...
- the next is timepast\ string: seconds past since timer start...
- the next is var<N>\ string: value of variable <N>... (N: 1..16)
- the next is logFile\ string: name of log file...
- the next is workPath\ string: current directory...
- the next is workExtns\ string: current file extension...
- the next is currFile\ string: current filename+extension...
- the next is prevfile\ string: previous file is searched...
- the next is nextfile\ string: next file is searched...
- the next is newfile\ string: a random named file is generated...
- the next is readEd\ string: the readed string...
- the next is readLen\ string: length of readed string...
- the next is connStr\ string: connect string...
- the next is date\ string: current date...
- the next is time\ string: current time...
- the next is datim\ string: current date+time...
- the next is driver\ string: pid of serial driver...
- the next is port\ string: port on serial driver...
- the next is voice\ string: 1 if voice capability available, else 0...
- the next is mdmBusy\ string: 1 if busy signal detected, else 0...
- the next is mdmDial\ string: 1 if dialtone detected, else 0...
- the next is mdmFaxAsw\ string: 1 if fax answer signal detected, else 0...
- the next is mdmFaxCal\ string: 1 if fax call signal detected, else 0...
- the next is mdmDatAsw\ string: 1 if data answer signal detected, else 0...
- the next is mdmDatCal\ string: 1 if data call signal detected, else 0...
- the next is mdmSilnc\ string: 1 if silence detected, else 0...
- the next is mdmQuiet\ string: 1 if "now silence, but heared voices", else 0...


 conditions
~~~~~~~~~~~~
<a> <e> <b> means that <a> is in <e> relation with <b>...
<a> and <b> are 'variables', and <e> is the relation, itself...
the relation is composed of characters with meaning:
n - convert values to numbers...
c - compare case insensitively...
< - if a<b then the result will be true...
> - if a>b then the result will be true...
= - if a=b then the result will be true...
@ - if b string contains a substring, then the result will be true...
this is not as difficult, as it seems, it works as in any programming
languages... i hope you can imagine what does a <= b means... the only
one trick is that the default comparation is the lexicographical...
(so i compare strings anyway;) it means that 55 will be smaller than 9,
but you can change this by putting the n character to the beginning.
this will change strings to numbers and continue with numberical comparing...


 calculations
~~~~~~~~~~~~~~
this is a very simple equalation system. there is no precedence,
everything is done from left to right, but you can use parentheses
to set the order of evaluation... in these calculations, every
component (numbers, operators, etc) are strings, so they have to be
separated by a space... you can use the following operators:
+ - & | ^ * / % << >> (and their names too: add sub and or xor mul
div mod shr shl). these operators calculate from left to right
and has no precedence, so 7 - 3 * 2 = 8...
if something cannot converted to number, the 0 will be assumed...
you have some comparator operators: < > <> =... these operators
compares their left and right parts, and the result will be 1
if the expression was true, and 0 otherwise... if there are
more comparators at the same parenthese level, then they are
evaluated from right to left, so a = b = c will be evaluated
as the a = ( b = c )...


 commands
~~~~~~~~~~
quit [errorcode]             - leave current script, place errorcode...
debugMode <bitmap>           - bit0=script, bit1=modem...
echo <string>                - display the string...
scriptFile <filename>        - run another script...
modemCommand <cmd>           - execute command on modem...
waitSomeTime <time>          - wait <time> seconds...
clearInputBuf                - flush input buffer...
clearDetect                  - clear detected states....
modemDevice <device>         - select output: linemute, phone, speaker, microphone, line...
setPortLine <b> [d] [p] [s]  - set line speed, data bits, parity, stop bits...
setPortFlow <f>              - set flow control: bit0=dtrcts, bit1=rtsdsr...
setPortModem <m>             - set modem control: bit0=dtr, bit1=rts...
portClose                    - close the port (before excution;)...
portOpen                     - open the port (after excution;)...
modemWaitRing                - wait for phone ringing; keys: enter=force, esc=fail...
modemAnswer [t]              - answer the modem, set timeout to t...
modemDial <num> [t]          - dial the number, set timeout to t...
modemHangup [retry]          - hangup the modem, set max retry...
modemReset                   - reset modem to voice mode....
modemDataMode                - switch modem to data mode...
modemRecord <f> <t> [k]      - record <t> seconds from modem to <f>, set [k] to abort keys...
modemPlay <f> [k]            - play <f> on modem, set [k] to abort keys...
modemRecPlay <p> <r> <t> [k] - play <p> while record to <r> for <t> seconds, set [k] to abort keys...
modemBeep <d> <t>            - play beep on modem for <t> seconds, <d> is frequency, or dtmf code...
modemReadLn <t> <m> [k]      - read <m> dtmf codes from modem for <t> seconds, set [k] to abort keys...
setCurrentDir <p>            - set working directory...
setLogFile <f>               - start log file...
setCurrentExt <e>            - set extension (with dots;)...
setCurrentFile <f>           - set current file...
setConnectStr <s>            - set last connect string...
setLastResult <v>            - set last action result...
setLastReaded <s>            - set last readed value...
setVariable<N> <s>           - set variable <N> to <s>... (N: 1..16)
calcVariable<N> <e>          - set variable <N> to value of <e> calculation...
scriptCommand <c>            - script command, parameters...
goto <l>                     - go to label...
gosub <l>                    - go to label, store return info...
return                       - reload return info...
<label>:                     - place a simple label for goto/gosub...
if <a> <e> <b> then <c>      - if <a> <e> <b> is true then do <c> command... (<c> should be goto;)
while <a> <e> <b> do <c>     - while <a> <e> <b> is true execute <c> command... (<c> should be gosub:)
exec <n> [p]                 - execute <n>, give [p] parameters... result=exitcode...
execBG <n> [p]               - execute <n> in background, give [p] parameters... result=pid...
execPR <n> [p]               - execute <n> as protocol, give [p] parameters...
binaryReadLn <t> <m> <k> [d] - read <m> characters from remote for <t> seconds, set <k> to abort keys, if [d]=1, won't echo...
binaryWrite <s>              - send <s> to remote station... (in data connection;)
startTimer                   - start the timer...
eraseFile <f>                - erase the file... result=errorcode...
createFile <f>               - create the file... result=errorcode...
renameFile <src> <trg>       - rename the file... result=errorcode...
openFileR <file>             - open file for reading, result=errorcode...
openFileW <file>             - open file for writing, result=errorcode...
closeFile                    - close the opened file...
readFile                     - read text from file to readEd, result=1 if eol...
readLnFile                   - read line from file to readEd, result=1 if eof...
writeFile <text>             - write text to file...
writeLnFile <text>           - write line to file...
stringUnplug <s>             - unplug string to readed...
stringSearch <sub> <str>     - find <sub> in <str>, place offset to result...
stringGetPart <s> <b> <s>    - copy <s> bytes beginning at <b> from <s> to readed...
stringLength <s>             - result will be the size of string...
stringLower <s>              - lower case string to readed...
stringUpper <s>              - upper case string to readed...
